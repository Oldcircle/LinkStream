var f=e=>{throw TypeError(e)};var h=(e,r,t)=>r.has(e)||f("Cannot "+t);var l=(e,r,t)=>(h(e,r,"read from private field"),t?t.call(e):r.get(e)),u=(e,r,t)=>r.has(e)?f("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(e):r.set(e,t),p=(e,r,t,n)=>(h(e,r,"write to private field"),n?n.call(e,t):r.set(e,t),t);import{A as v}from"./sticky-event-emitter-B3ySTSV4.js";import{c as y,e as E,s as d}from"./string-Gn2dS4oc.js";import{B as R,s as g,e as T}from"./struct-deserialize-bkGssrR1.js";function K(e){return new Promise(r=>{globalThis.setTimeout(()=>r(),e)})}var c;class x extends v{constructor(t){super();u(this,c);p(this,c,t)}get adb(){return l(this,c)}}c=new WeakMap;function S(e){if(e<48)throw new TypeError(`Invalid hex char ${e}`);if(e<58)return e-48;if(e<65)throw new TypeError(`Invalid hex char ${e}`);if(e<71)return e-55;if(e<97)throw new TypeError(`Invalid hex char ${e}`);if(e<103)return e-87;throw new TypeError(`Invalid hex char ${e}`)}function N(e){let r=0;for(let t=0;t<e.length;t+=1)r=r<<4|S(e[t]);return r}function P(e,r,t){const n=r;for(r+=3;r>=n&&t>0;){const s=t&15;t>>=4,s<10?e[r]=s+48:e[r]=s+87,r-=1}for(;r>=n;)e[r]=48,r-=1}const U=()=>{};function Y(...e){throw new Error(`Unreachable. Arguments:
`+e.join(`
`))}function $(e,r){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t+=1)if(e[t]!==r[t])return!1;return!0}const m=g({length:d(4),content:d({field:"length",convert(e){return Number.parseInt(e,16)},back(e){return e.toString(16).padStart(4,"0")}})},{littleEndian:!0});class b extends Error{constructor(r){super(r)}}class B extends b{constructor(){super("ADB reverse tunnel is not supported on this device when connected wirelessly.")}}const q=y(m,{},{postDeserialize(e){throw e.content==="more than one device/emulator"?new B:new b(e.content)}});function A(e){let r=0;for(const t of e){if(t<48||t>57)return r;r=r*10+t-48}return r}const k=E("OKAY");var o;class j extends x{constructor(){super(...arguments);u(this,o,new Map)}async createBufferedStream(t){const n=await this.adb.createSocket(t);return new R(n.readable)}async sendRequest(t){const n=await this.createBufferedStream(t),s=await n.readExactly(4);return $(s,k)||await q.deserialize(n),n}async list(){const t=await this.createBufferedStream("reverse:list-forward");return(await m.deserialize(t)).content.split(`
`).filter(s=>!!s).map(s=>{const[i,a,w]=s.split(" ");return{deviceSerial:i,localName:a,remoteName:w}})}async addExternal(t,n){const s=await this.sendRequest(`reverse:forward:${t};${n}`);if(t.startsWith("tcp:")){const i=s.position;try{const a=N(await s.readExactly(4));t=`tcp:${A(await s.readExactly(a))}`}catch(a){if(!(a instanceof T&&s.position===i))throw a}}return t}async add(t,n,s){s=await this.adb.transport.addReverseTunnel(n,s);try{return t=await this.addExternal(t,s),l(this,o).set(t,s),t}catch(i){throw await this.adb.transport.removeReverseTunnel(s),i}}async remove(t){const n=l(this,o).get(t);n&&await this.adb.transport.removeReverseTunnel(n),await this.sendRequest(`reverse:killforward:${t}`)}async removeAll(){await this.adb.transport.clearReverseTunnels(),l(this,o).clear(),await this.sendRequest("reverse:killforward-all")}}o=new WeakMap;export{x as A,U as N,j as a,b,B as c,K as d,N as h,$ as s,Y as u,P as w};
