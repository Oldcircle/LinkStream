var ho=Object.defineProperty;var _o=(e,t,r)=>t in e?ho(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var d=(e,t,r)=>_o(e,typeof t!="symbol"?t+"":t,r);var on=(function(){function e(){var t=this;this._state="running",this.resolve=function(r){t._resolve(r),t._state="resolved"},this.reject=function(r){t._reject(r),t._state="rejected"},this._promise=new Promise(function(r,n){t._resolve=r,t._reject=n})}return Object.defineProperty(e.prototype,"promise",{get:function(){return this._promise},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"state",{get:function(){return this._state},enumerable:!1,configurable:!0}),e})();/**
 * @license
 * web-streams-polyfill v4.2.0
 * Copyright 2025 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */function Ne(){}function L(e){return typeof e=="object"&&e!==null||typeof e=="function"}const sn=Ne;function S(e,t){try{Object.defineProperty(e,"name",{value:t,configurable:!0})}catch{}}const ur=Promise,bo=Promise.resolve.bind(ur),po=Promise.prototype.then,mo=Promise.reject.bind(ur),go=bo;function C(e){return new ur(e)}function T(e){return C(t=>t(e))}function h(e){return mo(e)}function V(e,t,r){return po.call(e,t,r)}function x(e,t,r){V(V(e,t,r),void 0,sn)}function Bt(e,t){x(e,t)}function Xt(e,t){x(e,void 0,t)}function X(e,t,r){return V(e,t,r)}function ke(e){V(e,void 0,sn)}let pe=e=>{if(typeof queueMicrotask=="function")pe=queueMicrotask;else{const t=T(void 0);pe=r=>V(t,r)}return pe(e)};function me(e,t,r){if(typeof e!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}function Z(e,t,r){try{return T(me(e,t,r))}catch(n){return h(n)}}class ${constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(t){const r=this._back;let n=r;r._elements.length===16383&&(n={_elements:[],_next:void 0}),r._elements.push(t),n!==r&&(this._back=n,r._next=n),++this._size}shift(){const t=this._front;let r=t;const n=this._cursor;let o=n+1;const i=t._elements,s=i[n];return o===16384&&(r=t._next,o=0),--this._size,this._cursor=o,t!==r&&(this._front=r),i[n]=void 0,s}forEach(t){let r=this._cursor,n=this._front,o=n._elements;for(;!(r===o.length&&n._next===void 0||r===o.length&&(n=n._next,o=n._elements,r=0,o.length===0));)t(o[r]),++r}peek(){const t=this._front,r=this._cursor;return t._elements[r]}}const an=Symbol("[[AbortSteps]]"),ln=Symbol("[[ErrorSteps]]"),cr=Symbol("[[CancelSteps]]"),dr=Symbol("[[PullSteps]]"),fr=Symbol("[[ReleaseSteps]]");function un(e,t){e._ownerReadableStream=t,t._reader=e,t._state==="readable"?Zt(e):t._state==="closed"?(function(r){Zt(r),dn(r)})(e):cn(e,t._storedError)}function hr(e,t){return A(e._ownerReadableStream,t)}function G(e){const t=e._ownerReadableStream;t._state==="readable"?_r(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):(function(r,n){cn(r,n)})(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),t._readableStreamController[fr](),t._reader=void 0,e._ownerReadableStream=void 0}function ft(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Zt(e){e._closedPromise=C((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r})}function cn(e,t){Zt(e),_r(e,t)}function _r(e,t){e._closedPromise_reject!==void 0&&(ke(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function dn(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}const kr=Number.isFinite||function(e){return typeof e=="number"&&isFinite(e)},yo=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function K(e,t){if(e!==void 0&&typeof(r=e)!="object"&&typeof r!="function")throw new TypeError(`${t} is not an object.`);var r}function U(e,t){if(typeof e!="function")throw new TypeError(`${t} is not a function.`)}function fn(e,t){if(!(function(r){return typeof r=="object"&&r!==null||typeof r=="function"})(e))throw new TypeError(`${t} is not an object.`)}function ge(e,t,r){if(e===void 0)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function Ir(e,t,r){if(e===void 0)throw new TypeError(`${t} is required in '${r}'.`)}function hn(e){return Number(e)}function Wr(e){return e===0?0:e}function br(e,t){const r=Number.MAX_SAFE_INTEGER;let n=Number(e);if(n=Wr(n),!kr(n))throw new TypeError(`${t} is not a finite number`);if(n=(function(o){return Wr(yo(o))})(n),n<0||n>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return kr(n)&&n!==0?n:0}function pr(e,t){if(!J(e))throw new TypeError(`${t} is not a ReadableStream.`)}function Oe(e){return new de(e)}function _n(e,t){e._reader._readRequests.push(t)}function mr(e,t,r){const n=e._reader._readRequests.shift();r?n._closeSteps():n._chunkSteps(t)}function Pt(e){return e._reader._readRequests.length}function bn(e){const t=e._reader;return t!==void 0&&!!ne(t)}class de{constructor(t){if(ge(t,1,"ReadableStreamDefaultReader"),pr(t,"First parameter"),oe(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");un(this,t),this._readRequests=new $}get closed(){return ne(this)?this._closedPromise:h(Xe("closed"))}cancel(t=void 0){return ne(this)?this._ownerReadableStream===void 0?h(ft("cancel")):hr(this,t):h(Xe("cancel"))}read(){if(!ne(this))return h(Xe("read"));if(this._ownerReadableStream===void 0)return h(ft("read from"));let t,r;const n=C((o,i)=>{t=o,r=i});return $e(this,{_chunkSteps:o=>t({value:o,done:!1}),_closeSteps:()=>t({value:void 0,done:!0}),_errorSteps:o=>r(o)}),n}releaseLock(){if(!ne(this))throw Xe("releaseLock");this._ownerReadableStream!==void 0&&(function(t){G(t);const r=new TypeError("Reader was released");pn(t,r)})(this)}}function ne(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")&&e instanceof de}function $e(e,t){const r=e._ownerReadableStream;r._disturbed=!0,r._state==="closed"?t._closeSteps():r._state==="errored"?t._errorSteps(r._storedError):r._readableStreamController[dr](t)}function pn(e,t){const r=e._readRequests;e._readRequests=new $,r.forEach(n=>{n._errorSteps(t)})}function Xe(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}var kt,It,Wt;function We(e){return e.slice()}function mn(e,t,r,n,o){new Uint8Array(e).set(new Uint8Array(r,n,o),t)}Object.defineProperties(de.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),S(de.prototype.cancel,"cancel"),S(de.prototype.read,"read"),S(de.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(de.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});let ye=e=>(ye=typeof e.transfer=="function"?t=>t.transfer():typeof structuredClone=="function"?t=>structuredClone(t,{transfer:[t]}):t=>t,ye(e)),we=e=>(we=typeof e.detached=="boolean"?t=>t.detached:t=>t.byteLength===0,we(e));function gn(e,t,r){if(e.slice)return e.slice(t,r);const n=r-t,o=new ArrayBuffer(n);return mn(o,0,e,t,n),o}function Fe(e,t){const r=e[t];if(r!=null){if(typeof r!="function")throw new TypeError(`${String(t)} is not a function`);return r}}function Fr(e){try{const t=e.done,r=e.value;return V(go(r),n=>({done:t,value:n}))}catch(t){return h(t)}}const He=(Wt=(kt=Symbol.asyncIterator)!==null&&kt!==void 0?kt:(It=Symbol.for)===null||It===void 0?void 0:It.call(Symbol,"Symbol.asyncIterator"))!==null&&Wt!==void 0?Wt:"@@asyncIterator";function yn(e,t="sync",r){if(r===void 0)if(t==="async"){if((r=Fe(e,He))===void 0)return(function(o){const i={next(){let s;try{s=wn(o)}catch(a){return h(a)}return Fr(s)},return(s){let a;try{const l=Fe(o.iterator,"return");if(l===void 0)return T({done:!0,value:s});a=me(l,o.iterator,[s])}catch(l){return h(l)}return L(a)?Fr(a):h(new TypeError("The iterator.return() method must return an object"))}};return{iterator:i,nextMethod:i.next,done:!1}})(yn(e,"sync",Fe(e,Symbol.iterator)))}else r=Fe(e,Symbol.iterator);if(r===void 0)throw new TypeError("The object is not iterable");const n=me(r,e,[]);if(!L(n))throw new TypeError("The iterator method must return an object");return{iterator:n,nextMethod:n.next,done:!1}}function wn(e){const t=me(e.nextMethod,e.iterator,[]);if(!L(t))throw new TypeError("The iterator.next() method must return an object");return t}class vn{constructor(t,r){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=t,this._preventCancel=r}next(){const t=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?X(this._ongoingPromise,t,t):t(),this._ongoingPromise}return(t){const r=()=>this._returnSteps(t);return this._ongoingPromise=this._ongoingPromise?X(this._ongoingPromise,r,r):r(),this._ongoingPromise}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const t=this._reader;let r,n;const o=C((i,s)=>{r=i,n=s});return $e(t,{_chunkSteps:i=>{this._ongoingPromise=void 0,pe(()=>r({value:i,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,G(t),r({value:void 0,done:!0})},_errorSteps:i=>{this._ongoingPromise=void 0,this._isFinished=!0,G(t),n(i)}}),o}_returnSteps(t){if(this._isFinished)return Promise.resolve({value:t,done:!0});this._isFinished=!0;const r=this._reader;if(!this._preventCancel){const n=hr(r,t);return G(r),X(n,()=>({value:t,done:!0}))}return G(r),T({value:t,done:!0})}}const Sn={next(){return Dr(this)?this._asyncIteratorImpl.next():h(xr("next"))},return(e){return Dr(this)?this._asyncIteratorImpl.return(e):h(xr("return"))},[He](){return this}};function Dr(e){if(!L(e)||!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl"))return!1;try{return e._asyncIteratorImpl instanceof vn}catch{return!1}}function xr(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}Object.defineProperty(Sn,He,{enumerable:!1});const Tn=Number.isNaN||function(e){return e!=e};function Nr(e){const t=gn(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}function Jt(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function gr(e,t,r){if(typeof(n=r)!="number"||Tn(n)||n<0||r===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var n;e._queue.push({value:t,size:r}),e._queueTotalSize+=r}function ae(e){e._queue=new $,e._queueTotalSize=0}function Rn(e){return e===DataView}class Pe{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!Ft(this))throw Dt("view");return this._view}respond(t){if(!Ft(this))throw Dt("respond");if(ge(t,1,"respond"),t=br(t,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(we(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");at(this._associatedReadableByteStreamController,t)}respondWithNewView(t){if(!Ft(this))throw Dt("respondWithNewView");if(ge(t,1,"respondWithNewView"),!ArrayBuffer.isView(t))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(we(t.buffer))throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");lt(this._associatedReadableByteStreamController,t)}}Object.defineProperties(Pe.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),S(Pe.prototype.respond,"respond"),S(Pe.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Pe.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class ee{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!fe(this))throw Ie("byobRequest");return er(this)}get desiredSize(){if(!fe(this))throw Ie("desiredSize");return In(this)}close(){if(!fe(this))throw Ie("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const t=this._controlledReadableByteStream._state;if(t!=="readable")throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);De(this)}enqueue(t){if(!fe(this))throw Ie("enqueue");if(ge(t,1,"enqueue"),!ArrayBuffer.isView(t))throw new TypeError("chunk must be an array buffer view");if(t.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(t.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if(r!=="readable")throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);st(this,t)}error(t=void 0){if(!fe(this))throw Ie("error");N(this,t)}[cr](t){En(this),ae(this);const r=this._cancelAlgorithm(t);return zt(this),r}[dr](t){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void kn(this,t);const n=this._autoAllocateChunkSize;if(n!==void 0){let o;try{o=new ArrayBuffer(n)}catch(s){return void t._errorSteps(s)}const i={buffer:o,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(i)}_n(r,t),Te(this)}[fr](){if(this._pendingPullIntos.length>0){const t=this._pendingPullIntos.peek();t.readerType="none",this._pendingPullIntos=new $,this._pendingPullIntos.push(t)}}}function fe(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")&&e instanceof ee}function Ft(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")&&e instanceof Pe}function Te(e){if((function(r){const n=r._controlledReadableByteStream;return n._state!=="readable"||r._closeRequested||!r._started?!1:!!(bn(n)&&Pt(n)>0||wr(n)&&Dn(n)>0||In(r)>0)})(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,x(e._pullAlgorithm(),()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,Te(e)),null),r=>(N(e,r),null))}}function En(e){yr(e),e._pendingPullIntos=new $}function Pn(e,t){let r=!1;e._state==="closed"&&(r=!0);const n=zn(t);t.readerType==="default"?mr(e,n,r):(function(o,i,s){const a=o._reader,l=a._readIntoRequests.shift();s?l._closeSteps(i):l._chunkSteps(i)})(e,n,r)}function ot(e,t){for(let r=0;r<t.length;++r)Pn(e,t[r])}function zn(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function it(e,t,r,n){e._queue.push({buffer:t,byteOffset:r,byteLength:n}),e._queueTotalSize+=n}function qn(e,t,r,n){let o;try{o=gn(t,r,r+n)}catch(i){throw N(e,i),i}it(e,o,0,n)}function On(e,t){t.bytesFilled>0&&qn(e,t.buffer,t.byteOffset,t.bytesFilled),Ce(e)}function Cn(e,t){const r=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),n=t.bytesFilled+r;let o=r,i=!1;const s=n-n%t.elementSize;s>=t.minimumFill&&(o=s-t.bytesFilled,i=!0);const a=e._queue;for(;o>0;){const l=a.peek(),c=Math.min(o,l.byteLength),f=t.byteOffset+t.bytesFilled;mn(t.buffer,f,l.buffer,l.byteOffset,c),l.byteLength===c?a.shift():(l.byteOffset+=c,l.byteLength-=c),e._queueTotalSize-=c,Ln(e,c,t),o-=c}return i}function Ln(e,t,r){r.bytesFilled+=t}function jn(e){e._queueTotalSize===0&&e._closeRequested?(zt(e),Ge(e._controlledReadableByteStream)):Te(e)}function yr(e){e._byobRequest!==null&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function Qt(e){const t=[];for(;e._pendingPullIntos.length>0&&e._queueTotalSize!==0;){const r=e._pendingPullIntos.peek();Cn(e,r)&&(Ce(e),t.push(r))}return t}function wo(e,t,r,n){const o=e._controlledReadableByteStream,i=t.constructor,s=(function(u){return Rn(u)?1:u.BYTES_PER_ELEMENT})(i),{byteOffset:a,byteLength:l}=t,c=r*s;let f;try{f=ye(t.buffer)}catch(u){return void n._errorSteps(u)}const _={buffer:f,bufferByteLength:f.byteLength,byteOffset:a,byteLength:l,bytesFilled:0,minimumFill:c,elementSize:s,viewConstructor:i,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(_),void $r(o,n);if(o._state==="closed"){const u=new i(_.buffer,_.byteOffset,0);return void n._closeSteps(u)}if(e._queueTotalSize>0){if(Cn(e,_)){const u=zn(_);return jn(e),void n._chunkSteps(u)}if(e._closeRequested){const u=new TypeError("Insufficient bytes to fill elements in the given buffer");return N(e,u),void n._errorSteps(u)}}e._pendingPullIntos.push(_),$r(o,n),Te(e)}function Bn(e,t){const r=e._pendingPullIntos.peek();yr(e),e._controlledReadableByteStream._state==="closed"?(function(n,o){o.readerType==="none"&&Ce(n);const i=n._controlledReadableByteStream;if(wr(i)){const s=[];for(;s.length<Dn(i);)s.push(Ce(n));ot(i,s)}})(e,r):(function(n,o,i){if(Ln(0,o,i),i.readerType==="none"){On(n,i);const l=Qt(n);return void ot(n._controlledReadableByteStream,l)}if(i.bytesFilled<i.minimumFill)return;Ce(n);const s=i.bytesFilled%i.elementSize;if(s>0){const l=i.byteOffset+i.bytesFilled;qn(n,i.buffer,l-s,s)}i.bytesFilled-=s;const a=Qt(n);Pn(n._controlledReadableByteStream,i),ot(n._controlledReadableByteStream,a)})(e,t,r),Te(e)}function Ce(e){return e._pendingPullIntos.shift()}function zt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function De(e){const t=e._controlledReadableByteStream;if(!e._closeRequested&&t._state==="readable")if(e._queueTotalSize>0)e._closeRequested=!0;else{if(e._pendingPullIntos.length>0){const r=e._pendingPullIntos.peek();if(r.bytesFilled%r.elementSize!==0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw N(e,n),n}}zt(e),Ge(t)}}function st(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||r._state!=="readable")return;const{buffer:n,byteOffset:o,byteLength:i}=t;if(we(n))throw new TypeError("chunk's buffer is detached and so cannot be enqueued");const s=ye(n);if(e._pendingPullIntos.length>0){const a=e._pendingPullIntos.peek();if(we(a.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");yr(e),a.buffer=ye(a.buffer),a.readerType==="none"&&On(e,a)}bn(r)?((function(a){const l=a._controlledReadableByteStream._reader;for(;l._readRequests.length>0;){if(a._queueTotalSize===0)return;kn(a,l._readRequests.shift())}})(e),Pt(r)===0?it(e,s,o,i):(e._pendingPullIntos.length>0&&Ce(e),mr(r,new Uint8Array(s,o,i),!1))):wr(r)?(it(e,s,o,i),ot(r,Qt(e))):it(e,s,o,i),Te(e)}function N(e,t){const r=e._controlledReadableByteStream;r._state==="readable"&&(En(e),ae(e),zt(e),oo(r,t))}function kn(e,t){const r=e._queue.shift();e._queueTotalSize-=r.byteLength,jn(e);const n=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);t._chunkSteps(n)}function er(e){if(e._byobRequest===null&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),n=Object.create(Pe.prototype);(function(o,i,s){o._associatedReadableByteStreamController=i,o._view=s})(n,e,r),e._byobRequest=n}return e._byobRequest}function In(e){const t=e._controlledReadableByteStream._state;return t==="errored"?null:t==="closed"?0:e._strategyHWM-e._queueTotalSize}function at(e,t){const r=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(t!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(t===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(r.bytesFilled+t>r.byteLength)throw new RangeError("bytesWritten out of range")}r.buffer=ye(r.buffer),Bn(e,t)}function lt(e,t){const r=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(t.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(t.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(r.bufferByteLength!==t.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(r.bytesFilled+t.byteLength>r.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const n=t.byteLength;r.buffer=ye(t.buffer),Bn(e,n)}function Wn(e,t,r,n,o,i,s){t._controlledReadableByteStream=e,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,ae(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=i,t._pullAlgorithm=n,t._cancelAlgorithm=o,t._autoAllocateChunkSize=s,t._pendingPullIntos=new $,e._readableStreamController=t,x(T(r()),()=>(t._started=!0,Te(t),null),a=>(N(t,a),null))}function Dt(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Ie(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function vo(e,t){if((e=`${e}`)!="byob")throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function Fn(e){return new he(e)}function $r(e,t){e._reader._readIntoRequests.push(t)}function Dn(e){return e._reader._readIntoRequests.length}function wr(e){const t=e._reader;return t!==void 0&&!!be(t)}Object.defineProperties(ee.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),S(ee.prototype.close,"close"),S(ee.prototype.enqueue,"enqueue"),S(ee.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ee.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class he{constructor(t){if(ge(t,1,"ReadableStreamBYOBReader"),pr(t,"First parameter"),oe(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!fe(t._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");un(this,t),this._readIntoRequests=new $}get closed(){return be(this)?this._closedPromise:h(Ze("closed"))}cancel(t=void 0){return be(this)?this._ownerReadableStream===void 0?h(ft("cancel")):hr(this,t):h(Ze("cancel"))}read(t,r={}){if(!be(this))return h(Ze("read"));if(!ArrayBuffer.isView(t))return h(new TypeError("view must be an array buffer view"));if(t.byteLength===0)return h(new TypeError("view must have non-zero byteLength"));if(t.buffer.byteLength===0)return h(new TypeError("view's buffer must have non-zero byteLength"));if(we(t.buffer))return h(new TypeError("view's buffer has been detached"));let n;try{n=(function(l,c){var f;return K(l,c),{min:br((f=l==null?void 0:l.min)!==null&&f!==void 0?f:1,`${c} has member 'min' that`)}})(r,"options")}catch(l){return h(l)}const o=n.min;if(o===0)return h(new TypeError("options.min must be greater than 0"));if((function(l){return Rn(l.constructor)})(t)){if(o>t.byteLength)return h(new RangeError("options.min must be less than or equal to view's byteLength"))}else if(o>t.length)return h(new RangeError("options.min must be less than or equal to view's length"));if(this._ownerReadableStream===void 0)return h(ft("read from"));let i,s;const a=C((l,c)=>{i=l,s=c});return xn(this,t,o,{_chunkSteps:l=>i({value:l,done:!1}),_closeSteps:l=>i({value:l,done:!0}),_errorSteps:l=>s(l)}),a}releaseLock(){if(!be(this))throw Ze("releaseLock");this._ownerReadableStream!==void 0&&(function(t){G(t);const r=new TypeError("Reader was released");Nn(t,r)})(this)}}function be(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")&&e instanceof he}function xn(e,t,r,n){const o=e._ownerReadableStream;o._disturbed=!0,o._state==="errored"?n._errorSteps(o._storedError):wo(o._readableStreamController,t,r,n)}function Nn(e,t){const r=e._readIntoRequests;e._readIntoRequests=new $,r.forEach(n=>{n._errorSteps(t)})}function Ze(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Ue(e,t){const{highWaterMark:r}=e;if(r===void 0)return t;if(Tn(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}function ht(e){const{size:t}=e;return t||(()=>1)}function _t(e,t){K(e,t);const r=e==null?void 0:e.highWaterMark,n=e==null?void 0:e.size;return{highWaterMark:r===void 0?void 0:hn(r),size:n===void 0?void 0:So(n,`${t} has member 'size' that`)}}function So(e,t){return U(e,t),r=>hn(e(r))}function To(e,t,r){return U(e,r),n=>Z(e,t,[n])}function Ro(e,t,r){return U(e,r),()=>Z(e,t,[])}function Eo(e,t,r){return U(e,r),n=>me(e,t,[n])}function Po(e,t,r){return U(e,r),(n,o)=>Z(e,t,[n,o])}function $n(e,t){if(!ze(e))throw new TypeError(`${t} is not a WritableStream.`)}Object.defineProperties(he.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),S(he.prototype.cancel,"cancel"),S(he.prototype.read,"read"),S(he.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(he.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});let te=class{constructor(t={},r={}){t===void 0?t=null:fn(t,"First parameter");const n=_t(r,"Second parameter"),o=(function(s,a){K(s,a);const l=s==null?void 0:s.abort,c=s==null?void 0:s.close,f=s==null?void 0:s.start,_=s==null?void 0:s.type,u=s==null?void 0:s.write;return{abort:l===void 0?void 0:To(l,s,`${a} has member 'abort' that`),close:c===void 0?void 0:Ro(c,s,`${a} has member 'close' that`),start:f===void 0?void 0:Eo(f,s,`${a} has member 'start' that`),write:u===void 0?void 0:Po(u,s,`${a} has member 'write' that`),type:_}})(t,"First parameter");if(An(this),o.type!==void 0)throw new RangeError("Invalid type is specified");const i=ht(n);(function(s,a,l,c){const f=Object.create(Ae.prototype);let _,u,b,P;_=a.start!==void 0?()=>a.start(f):()=>{},u=a.write!==void 0?O=>a.write(O,f):()=>T(void 0),b=a.close!==void 0?()=>a.close():()=>T(void 0),P=a.abort!==void 0?O=>a.abort(O):()=>T(void 0),Xn(s,f,_,u,b,P,l,c)})(this,o,Ue(n,1),i)}get locked(){if(!ze(this))throw Qe("locked");return Le(this)}abort(t=void 0){return ze(this)?Le(this)?h(new TypeError("Cannot abort a stream that already has a writer")):bt(this,t):h(Qe("abort"))}close(){return ze(this)?Le(this)?h(new TypeError("Cannot close a stream that already has a writer")):Y(this)?h(new TypeError("Cannot close an already-closing stream")):Mn(this):h(Qe("close"))}getWriter(){if(!ze(this))throw Qe("getWriter");return Un(this)}};function Un(e){return new Q(e)}function An(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new $,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function ze(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")&&e instanceof te}function Le(e){return e._writer!==void 0}function bt(e,t){var r;if(e._state==="closed"||e._state==="errored")return T(void 0);e._writableStreamController._abortReason=t,(r=e._writableStreamController._abortController)===null||r===void 0||r.abort(t);const n=e._state;if(n==="closed"||n==="errored")return T(void 0);if(e._pendingAbortRequest!==void 0)return e._pendingAbortRequest._promise;let o=!1;n==="erroring"&&(o=!0,t=void 0);const i=C((s,a)=>{e._pendingAbortRequest={_promise:void 0,_resolve:s,_reject:a,_reason:t,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=i,o||vr(e,t),i}function Mn(e){const t=e._state;if(t==="closed"||t==="errored")return h(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=C((i,s)=>{const a={_resolve:i,_reject:s};e._closeRequest=a}),n=e._writer;var o;return n!==void 0&&e._backpressure&&t==="writable"&&Pr(n),gr(o=e._writableStreamController,Kn,0),qt(o),r}function tr(e,t){e._state!=="writable"?Sr(e):vr(e,t)}function vr(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const n=e._writer;n!==void 0&&Yn(n,t),!(function(o){return!(o._inFlightWriteRequest===void 0&&o._inFlightCloseRequest===void 0)})(e)&&r._started&&Sr(e)}function Sr(e){e._state="errored",e._writableStreamController[ln]();const t=e._storedError;if(e._writeRequests.forEach(n=>{n._reject(t)}),e._writeRequests=new $,e._pendingAbortRequest===void 0)return void Je(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void Je(e);x(e._writableStreamController[an](r._reason),()=>(r._resolve(),Je(e),null),n=>(r._reject(n),Je(e),null))}function Y(e){return e._closeRequest!==void 0||e._inFlightCloseRequest!==void 0}function Je(e){e._closeRequest!==void 0&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;t!==void 0&&Er(t,e._storedError)}function Tr(e,t){const r=e._writer;r!==void 0&&t!==e._backpressure&&(t?(function(n){Ot(n)})(r):Pr(r)),e._backpressure=t}Object.defineProperties(te.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),S(te.prototype.abort,"abort"),S(te.prototype.close,"close"),S(te.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(te.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});class Q{constructor(t){if(ge(t,1,"WritableStreamDefaultWriter"),$n(t,"First parameter"),Le(t))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=t,t._writer=this;const r=t._state;if(r==="writable")!Y(t)&&t._backpressure?Ot(this):Ur(this),ut(this);else if(r==="erroring")rr(this,t._storedError),ut(this);else if(r==="closed")Ur(this),ut(n=this),eo(n);else{const o=t._storedError;rr(this,o),Qn(this,o)}var n}get closed(){return le(this)?this._closedPromise:h(ue("closed"))}get desiredSize(){if(!le(this))throw ue("desiredSize");if(this._ownerWritableStream===void 0)throw xe("desiredSize");return(function(t){const r=t._ownerWritableStream,n=r._state;return n==="errored"||n==="erroring"?null:n==="closed"?0:Zn(r._writableStreamController)})(this)}get ready(){return le(this)?this._readyPromise:h(ue("ready"))}abort(t=void 0){return le(this)?this._ownerWritableStream===void 0?h(xe("abort")):(function(r,n){return bt(r._ownerWritableStream,n)})(this,t):h(ue("abort"))}close(){if(!le(this))return h(ue("close"));const t=this._ownerWritableStream;return t===void 0?h(xe("close")):Y(t)?h(new TypeError("Cannot close an already-closing stream")):Vn(this)}releaseLock(){if(!le(this))throw ue("releaseLock");this._ownerWritableStream!==void 0&&Hn(this)}write(t=void 0){return le(this)?this._ownerWritableStream===void 0?h(xe("write to")):Gn(this,t):h(ue("write"))}}function le(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")&&e instanceof Q}function Vn(e){return Mn(e._ownerWritableStream)}function zo(e,t){e._closedPromiseState==="pending"?Er(e,t):(function(r,n){Qn(r,n)})(e,t)}function Yn(e,t){e._readyPromiseState==="pending"?to(e,t):(function(r,n){rr(r,n)})(e,t)}function Hn(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Yn(e,r),zo(e,r),t._writer=void 0,e._ownerWritableStream=void 0}function Gn(e,t){const r=e._ownerWritableStream,n=r._writableStreamController,o=(function(a,l){if(a._strategySizeAlgorithm===void 0)return 1;try{return a._strategySizeAlgorithm(l)}catch(c){return Me(a,c),1}})(n,t);if(r!==e._ownerWritableStream)return h(xe("write to"));const i=r._state;if(i==="errored")return h(r._storedError);if(Y(r)||i==="closed")return h(new TypeError("The stream is closing or closed and cannot be written to"));if(i==="erroring")return h(r._storedError);const s=(function(a){return C((l,c)=>{const f={_resolve:l,_reject:c};a._writeRequests.push(f)})})(r);return(function(a,l,c){try{gr(a,l,c)}catch(_){return void Me(a,_)}const f=a._controlledWritableStream;!Y(f)&&f._state==="writable"&&Tr(f,Rr(a)),qt(a)})(n,t,o),s}Object.defineProperties(Q.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),S(Q.prototype.abort,"abort"),S(Q.prototype.close,"close"),S(Q.prototype.releaseLock,"releaseLock"),S(Q.prototype.write,"write"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Q.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const Kn={};class Ae{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!xt(this))throw Nt("abortReason");return this._abortReason}get signal(){if(!xt(this))throw Nt("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(t=void 0){if(!xt(this))throw Nt("error");this._controlledWritableStream._state==="writable"&&Jn(this,t)}[an](t){const r=this._abortAlgorithm(t);return pt(this),r}[ln](){ae(this)}}function xt(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")&&e instanceof Ae}function Xn(e,t,r,n,o,i,s,a){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,ae(t),t._abortReason=void 0,t._abortController=(function(){if(typeof AbortController=="function")return new AbortController})(),t._started=!1,t._strategySizeAlgorithm=a,t._strategyHWM=s,t._writeAlgorithm=n,t._closeAlgorithm=o,t._abortAlgorithm=i;const l=Rr(t);Tr(e,l),x(T(r()),()=>(t._started=!0,qt(t),null),c=>(t._started=!0,tr(e,c),null))}function pt(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function Zn(e){return e._strategyHWM-e._queueTotalSize}function qt(e){const t=e._controlledWritableStream;if(!e._started||t._inFlightWriteRequest!==void 0)return;if(t._state==="erroring")return void Sr(t);if(e._queue.length===0)return;const r=e._queue.peek().value;r===Kn?(function(n){const o=n._controlledWritableStream;(function(s){s._inFlightCloseRequest=s._closeRequest,s._closeRequest=void 0})(o),Jt(n);const i=n._closeAlgorithm();pt(n),x(i,()=>((function(s){s._inFlightCloseRequest._resolve(void 0),s._inFlightCloseRequest=void 0,s._state==="erroring"&&(s._storedError=void 0,s._pendingAbortRequest!==void 0&&(s._pendingAbortRequest._resolve(),s._pendingAbortRequest=void 0)),s._state="closed";const a=s._writer;a!==void 0&&eo(a)})(o),null),s=>((function(a,l){a._inFlightCloseRequest._reject(l),a._inFlightCloseRequest=void 0,a._pendingAbortRequest!==void 0&&(a._pendingAbortRequest._reject(l),a._pendingAbortRequest=void 0),tr(a,l)})(o,s),null))})(e):(function(n,o){const i=n._controlledWritableStream;(function(a){a._inFlightWriteRequest=a._writeRequests.shift()})(i);const s=n._writeAlgorithm(o);x(s,()=>{(function(l){l._inFlightWriteRequest._resolve(void 0),l._inFlightWriteRequest=void 0})(i);const a=i._state;if(Jt(n),!Y(i)&&a==="writable"){const l=Rr(n);Tr(i,l)}return qt(n),null},a=>(i._state==="writable"&&pt(n),(function(l,c){l._inFlightWriteRequest._reject(c),l._inFlightWriteRequest=void 0,tr(l,c)})(i,a),null))})(e,r)}function Me(e,t){e._controlledWritableStream._state==="writable"&&Jn(e,t)}function Rr(e){return Zn(e)<=0}function Jn(e,t){const r=e._controlledWritableStream;pt(e),vr(r,t)}function Qe(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function Nt(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function ue(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function xe(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function ut(e){e._closedPromise=C((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending"})}function Qn(e,t){ut(e),Er(e,t)}function Er(e,t){e._closedPromise_reject!==void 0&&(ke(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected")}function eo(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved")}function Ot(e){e._readyPromise=C((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r}),e._readyPromiseState="pending"}function rr(e,t){Ot(e),to(e,t)}function Ur(e){Ot(e),Pr(e)}function to(e,t){e._readyPromise_reject!==void 0&&(ke(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected")}function Pr(e){e._readyPromise_resolve!==void 0&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled")}Object.defineProperties(Ae.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Ae.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const Ar=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:void 0,qo=(function(){const e=Ar==null?void 0:Ar.DOMException;return(function(t){if(typeof t!="function"&&typeof t!="object"||t.name!=="DOMException")return!1;try{return new t,!0}catch{return!1}})(e)?e:void 0})()||(function(){const e=function(t,r){this.message=t||"",this.name=r||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return S(e,"DOMException"),e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,"constructor",{value:e,writable:!0,configurable:!0}),e})();function Mr(e,t,r,n,o,i){const s=Oe(e),a=Un(t);e._disturbed=!0;let l=!1,c=T(void 0);return C((f,_)=>{let u;if(i!==void 0){if(u=()=>{const g=i.reason!==void 0?i.reason:new qo("Aborted","AbortError"),q=[];n||q.push(()=>t._state==="writable"?bt(t,g):T(void 0)),o||q.push(()=>e._state==="readable"?A(e,g):T(void 0)),y(()=>Promise.all(q.map(w=>w())),!0,g)},i.aborted)return void u();i.addEventListener("abort",u)}var b,P,O;if(k(e,s._closedPromise,g=>(n?R(!0,g):y(()=>bt(t,g),!0,g),null)),k(t,a._closedPromise,g=>(o?R(!0,g):y(()=>A(e,g),!0,g),null)),b=e,P=s._closedPromise,O=()=>(r?R():y(()=>(function(g){const q=g._ownerWritableStream,w=q._state;return Y(q)||w==="closed"?T(void 0):w==="errored"?h(q._storedError):Vn(g)})(a)),null),b._state==="closed"?O():Bt(P,O),Y(t)||t._state==="closed"){const g=new TypeError("the destination writable stream closed before all data could be piped to it");o?R(!0,g):y(()=>A(e,g),!0,g)}function F(){const g=c;return V(c,()=>g!==c?F():void 0)}function k(g,q,w){g._state==="errored"?w(g._storedError):Xt(q,w)}function y(g,q,w){function v(){return x(g(),()=>I(q,w),p=>I(!0,p)),null}l||(l=!0,t._state!=="writable"||Y(t)?v():Bt(F(),v))}function R(g,q){l||(l=!0,t._state!=="writable"||Y(t)?I(g,q):Bt(F(),()=>I(g,q)))}function I(g,q){return Hn(a),G(s),i!==void 0&&i.removeEventListener("abort",u),g?_(q):f(void 0),null}ke(C((g,q)=>{(function w(v){v?g():V(l?T(!0):V(a._readyPromise,()=>C((p,E)=>{$e(s,{_chunkSteps:m=>{c=V(Gn(a,m),void 0,Ne),p(!1)},_closeSteps:()=>p(!0),_errorSteps:E})})),w,q)})(!1)}))})}class re{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!et(this))throw tt("desiredSize");return zr(this)}close(){if(!et(this))throw tt("close");if(!Be(this))throw new TypeError("The stream is not in a state that permits close");ve(this)}enqueue(t=void 0){if(!et(this))throw tt("enqueue");if(!Be(this))throw new TypeError("The stream is not in a state that permits enqueue");return je(this,t)}error(t=void 0){if(!et(this))throw tt("error");M(this,t)}[cr](t){ae(this);const r=this._cancelAlgorithm(t);return mt(this),r}[dr](t){const r=this._controlledReadableStream;if(this._queue.length>0){const n=Jt(this);this._closeRequested&&this._queue.length===0?(mt(this),Ge(r)):Ve(this),t._chunkSteps(n)}else _n(r,t),Ve(this)}[fr](){}}function et(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")&&e instanceof re}function Ve(e){if(ro(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,x(e._pullAlgorithm(),()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,Ve(e)),null),t=>(M(e,t),null))}}function ro(e){const t=e._controlledReadableStream;return!Be(e)||!e._started?!1:oe(t)&&Pt(t)>0?!0:zr(e)>0}function mt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function ve(e){if(!Be(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,e._queue.length===0&&(mt(e),Ge(t))}function je(e,t){if(!Be(e))return;const r=e._controlledReadableStream;if(oe(r)&&Pt(r)>0)mr(r,t,!1);else{let n;try{n=e._strategySizeAlgorithm(t)}catch(o){throw M(e,o),o}try{gr(e,t,n)}catch(o){throw M(e,o),o}}Ve(e)}function M(e,t){const r=e._controlledReadableStream;r._state==="readable"&&(ae(e),mt(e),oo(r,t))}function zr(e){const t=e._controlledReadableStream._state;return t==="errored"?null:t==="closed"?0:e._strategyHWM-e._queueTotalSize}function Be(e){const t=e._controlledReadableStream._state;return!e._closeRequested&&t==="readable"}function no(e,t,r,n,o,i,s){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,ae(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=s,t._strategyHWM=i,t._pullAlgorithm=n,t._cancelAlgorithm=o,e._readableStreamController=t,x(T(r()),()=>(t._started=!0,Ve(t),null),a=>(M(t,a),null))}function tt(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Oo(e,t){return fe(e._readableStreamController)?(function(r){let n,o,i,s,a,l=Oe(r),c=!1,f=!1,_=!1,u=!1,b=!1;const P=C(w=>{a=w});function O(w){Xt(w._closedPromise,v=>(w!==l||(N(i._readableStreamController,v),N(s._readableStreamController,v),u&&b||a(void 0)),null))}function F(){be(l)&&(G(l),l=Oe(r),O(l)),$e(l,{_chunkSteps:w=>{pe(()=>{f=!1,_=!1;const v=w;let p=w;if(!u&&!b)try{p=Nr(w)}catch(E){return N(i._readableStreamController,E),N(s._readableStreamController,E),void a(A(r,E))}u||st(i._readableStreamController,v),b||st(s._readableStreamController,p),c=!1,f?y():_&&R()})},_closeSteps:()=>{c=!1,u||De(i._readableStreamController),b||De(s._readableStreamController),i._readableStreamController._pendingPullIntos.length>0&&at(i._readableStreamController,0),s._readableStreamController._pendingPullIntos.length>0&&at(s._readableStreamController,0),u&&b||a(void 0)},_errorSteps:()=>{c=!1}})}function k(w,v){ne(l)&&(G(l),l=Fn(r),O(l));const p=v?s:i,E=v?i:s;xn(l,w,1,{_chunkSteps:m=>{pe(()=>{f=!1,_=!1;const z=v?b:u;if(v?u:b)z||lt(p._readableStreamController,m);else{let D;try{D=Nr(m)}catch(B){return N(p._readableStreamController,B),N(E._readableStreamController,B),void a(A(r,B))}z||lt(p._readableStreamController,m),st(E._readableStreamController,D)}c=!1,f?y():_&&R()})},_closeSteps:m=>{c=!1;const z=v?b:u,D=v?u:b;z||De(p._readableStreamController),D||De(E._readableStreamController),m!==void 0&&(z||lt(p._readableStreamController,m),!D&&E._readableStreamController._pendingPullIntos.length>0&&at(E._readableStreamController,0)),z&&D||a(void 0)},_errorSteps:()=>{c=!1}})}function y(){if(c)return f=!0,T(void 0);c=!0;const w=er(i._readableStreamController);return w===null?F():k(w._view,!1),T(void 0)}function R(){if(c)return _=!0,T(void 0);c=!0;const w=er(s._readableStreamController);return w===null?F():k(w._view,!0),T(void 0)}function I(w){if(u=!0,n=w,b){const v=We([n,o]),p=A(r,v);a(p)}return P}function g(w){if(b=!0,o=w,u){const v=We([n,o]),p=A(r,v);a(p)}return P}function q(){}return i=Yr(q,y,I),s=Yr(q,R,g),O(l),[i,s]})(e):(function(r){const n=Oe(r);let o,i,s,a,l,c=!1,f=!1,_=!1,u=!1;const b=C(y=>{l=y});function P(){return c?(f=!0,T(void 0)):(c=!0,$e(n,{_chunkSteps:y=>{pe(()=>{f=!1;const R=y,I=y;_||je(s._readableStreamController,R),u||je(a._readableStreamController,I),c=!1,f&&P()})},_closeSteps:()=>{c=!1,_||ve(s._readableStreamController),u||ve(a._readableStreamController),_&&u||l(void 0)},_errorSteps:()=>{c=!1}}),T(void 0))}function O(y){if(_=!0,o=y,u){const R=We([o,i]),I=A(r,R);l(I)}return b}function F(y){if(u=!0,i=y,_){const R=We([o,i]),I=A(r,R);l(I)}return b}function k(){}return s=Ye(k,P,O),a=Ye(k,P,F),Xt(n._closedPromise,y=>(M(s._readableStreamController,y),M(a._readableStreamController,y),_&&u||l(void 0),null)),[s,a]})(e)}function Co(e){return L(t=e)&&t.getReader!==void 0?(function(r){let n;function o(){let s;try{s=r.read()}catch(a){return h(a)}return X(s,a=>{if(!L(a))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(a.done)ve(n._readableStreamController);else{const l=a.value;je(n._readableStreamController,l)}})}function i(s){try{return T(r.cancel(s))}catch(a){return h(a)}}return n=Ye(Ne,o,i,0),n})(e.getReader()):(function(r){let n;const o=yn(r,"async");function i(){let a;try{a=wn(o)}catch(l){return h(l)}return X(T(a),l=>{if(!L(l))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(l.done)ve(n._readableStreamController);else{const c=l.value;je(n._readableStreamController,c)}})}function s(a){const l=o.iterator;let c;try{c=Fe(l,"return")}catch(f){return h(f)}return c===void 0?T(void 0):X(Z(c,l,[a]),f=>{if(!L(f))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")})}return n=Ye(Ne,i,s,0),n})(e);var t}function Lo(e,t,r){return U(e,r),n=>Z(e,t,[n])}function jo(e,t,r){return U(e,r),n=>Z(e,t,[n])}function Bo(e,t,r){return U(e,r),n=>me(e,t,[n])}function ko(e,t){if((e=`${e}`)!="bytes")throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function Vr(e,t){K(e,t);const r=e==null?void 0:e.preventAbort,n=e==null?void 0:e.preventCancel,o=e==null?void 0:e.preventClose,i=e==null?void 0:e.signal;return i!==void 0&&(function(s,a){if(!(function(l){if(typeof l!="object"||l===null)return!1;try{return typeof l.aborted=="boolean"}catch{return!1}})(s))throw new TypeError(`${a} is not an AbortSignal.`)})(i,`${t} has member 'signal' that`),{preventAbort:!!r,preventCancel:!!n,preventClose:!!o,signal:i}}Object.defineProperties(re.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),S(re.prototype.close,"close"),S(re.prototype.enqueue,"enqueue"),S(re.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(re.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});let W=class{constructor(t={},r={}){t===void 0?t=null:fn(t,"First parameter");const n=_t(r,"Second parameter"),o=(function(i,s){K(i,s);const a=i,l=a==null?void 0:a.autoAllocateChunkSize,c=a==null?void 0:a.cancel,f=a==null?void 0:a.pull,_=a==null?void 0:a.start,u=a==null?void 0:a.type;return{autoAllocateChunkSize:l===void 0?void 0:br(l,`${s} has member 'autoAllocateChunkSize' that`),cancel:c===void 0?void 0:Lo(c,a,`${s} has member 'cancel' that`),pull:f===void 0?void 0:jo(f,a,`${s} has member 'pull' that`),start:_===void 0?void 0:Bo(_,a,`${s} has member 'start' that`),type:u===void 0?void 0:ko(u,`${s} has member 'type' that`)}})(t,"First parameter");if(qr(this),o.type==="bytes"){if(n.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");(function(i,s,a){const l=Object.create(ee.prototype);let c,f,_;c=s.start!==void 0?()=>s.start(l):()=>{},f=s.pull!==void 0?()=>s.pull(l):()=>T(void 0),_=s.cancel!==void 0?b=>s.cancel(b):()=>T(void 0);const u=s.autoAllocateChunkSize;if(u===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");Wn(i,l,c,f,_,a,u)})(this,o,Ue(n,0))}else{const i=ht(n);(function(s,a,l,c){const f=Object.create(re.prototype);let _,u,b;_=a.start!==void 0?()=>a.start(f):()=>{},u=a.pull!==void 0?()=>a.pull(f):()=>T(void 0),b=a.cancel!==void 0?P=>a.cancel(P):()=>T(void 0),no(s,f,_,u,b,l,c)})(this,o,Ue(n,1),i)}}get locked(){if(!J(this))throw ce("locked");return oe(this)}cancel(t=void 0){return J(this)?oe(this)?h(new TypeError("Cannot cancel a stream that already has a reader")):A(this,t):h(ce("cancel"))}getReader(t=void 0){if(!J(this))throw ce("getReader");return(function(r,n){K(r,n);const o=r==null?void 0:r.mode;return{mode:o===void 0?void 0:vo(o,`${n} has member 'mode' that`)}})(t,"First parameter").mode===void 0?Oe(this):Fn(this)}pipeThrough(t,r={}){if(!J(this))throw ce("pipeThrough");ge(t,1,"pipeThrough");const n=(function(i,s){K(i,s);const a=i==null?void 0:i.readable;Ir(a,"readable","ReadableWritablePair"),pr(a,`${s} has member 'readable' that`);const l=i==null?void 0:i.writable;return Ir(l,"writable","ReadableWritablePair"),$n(l,`${s} has member 'writable' that`),{readable:a,writable:l}})(t,"First parameter"),o=Vr(r,"Second parameter");if(oe(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Le(n.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return ke(Mr(this,n.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal)),n.readable}pipeTo(t,r={}){if(!J(this))return h(ce("pipeTo"));if(t===void 0)return h("Parameter 1 is required in 'pipeTo'.");if(!ze(t))return h(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let n;try{n=Vr(r,"Second parameter")}catch(o){return h(o)}return oe(this)?h(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):Le(t)?h(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Mr(this,t,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!J(this))throw ce("tee");return We(Oo(this))}values(t=void 0){if(!J(this))throw ce("values");return(function(r,n){const o=Oe(r),i=new vn(o,n),s=Object.create(Sn);return s._asyncIteratorImpl=i,s})(this,(function(r,n){return K(r,n),{preventCancel:!!(r==null?void 0:r.preventCancel)}})(t,"First parameter").preventCancel)}[He](t){return this.values(t)}static from(t){return Co(t)}};function Ye(e,t,r,n=1,o=()=>1){const i=Object.create(W.prototype);return qr(i),no(i,Object.create(re.prototype),e,t,r,n,o),i}function Yr(e,t,r){const n=Object.create(W.prototype);return qr(n),Wn(n,Object.create(ee.prototype),e,t,r,0,void 0),n}function qr(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function J(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")&&e instanceof W}function oe(e){return e._reader!==void 0}function A(e,t){if(e._disturbed=!0,e._state==="closed")return T(void 0);if(e._state==="errored")return h(e._storedError);Ge(e);const r=e._reader;if(r!==void 0&&be(r)){const n=r._readIntoRequests;r._readIntoRequests=new $,n.forEach(o=>{o._closeSteps(void 0)})}return X(e._readableStreamController[cr](t),Ne)}function Ge(e){e._state="closed";const t=e._reader;if(t!==void 0&&(dn(t),ne(t))){const r=t._readRequests;t._readRequests=new $,r.forEach(n=>{n._closeSteps()})}}function oo(e,t){e._state="errored",e._storedError=t;const r=e._reader;r!==void 0&&(_r(r,t),ne(r)?pn(r,t):Nn(r,t))}function ce(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}Object.defineProperties(W,{from:{enumerable:!0}}),Object.defineProperties(W.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),S(W.from,"from"),S(W.prototype.cancel,"cancel"),S(W.prototype.getReader,"getReader"),S(W.prototype.pipeThrough,"pipeThrough"),S(W.prototype.pipeTo,"pipeTo"),S(W.prototype.tee,"tee"),S(W.prototype.values,"values"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(W.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),Object.defineProperty(W.prototype,He,{value:W.prototype.values,writable:!0,configurable:!0});const Io=e=>e.byteLength;S(Io,"size");const Wo=()=>1;S(Wo,"size");function Fo(e,t,r){return U(e,r),n=>Z(e,t,[n])}function Do(e,t,r){return U(e,r),n=>me(e,t,[n])}function xo(e,t,r){return U(e,r),(n,o)=>Z(e,t,[n,o])}function No(e,t,r){return U(e,r),n=>Z(e,t,[n])}let gt=class{constructor(t={},r={},n={}){t===void 0&&(t=null);const o=_t(r,"Second parameter"),i=_t(n,"Third parameter"),s=(function(u,b){K(u,b);const P=u==null?void 0:u.cancel,O=u==null?void 0:u.flush,F=u==null?void 0:u.readableType,k=u==null?void 0:u.start,y=u==null?void 0:u.transform,R=u==null?void 0:u.writableType;return{cancel:P===void 0?void 0:No(P,u,`${b} has member 'cancel' that`),flush:O===void 0?void 0:Fo(O,u,`${b} has member 'flush' that`),readableType:F,start:k===void 0?void 0:Do(k,u,`${b} has member 'start' that`),transform:y===void 0?void 0:xo(y,u,`${b} has member 'transform' that`),writableType:R}})(t,"First parameter");if(s.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(s.writableType!==void 0)throw new RangeError("Invalid writableType specified");const a=Ue(i,0),l=ht(i),c=Ue(o,1),f=ht(o);let _;(function(u,b,P,O,F,k){function y(){return b}function R(v){return(function(p,E){const m=p._transformStreamController;return p._backpressure?X(p._backpressureChangePromise,()=>{const z=p._writable;if(z._state==="erroring")throw z._storedError;return Gr(m,E)}):Gr(m,E)})(u,v)}function I(v){return(function(p,E){const m=p._transformStreamController;if(m._finishPromise!==void 0)return m._finishPromise;const z=p._readable;m._finishPromise=C((B,jt)=>{m._finishPromise_resolve=B,m._finishPromise_reject=jt});const D=m._cancelAlgorithm(E);return ct(m),x(D,()=>(z._state==="errored"?Re(m,z._storedError):(M(z._readableStreamController,E),$t(m)),null),B=>(M(z._readableStreamController,B),Re(m,B),null)),m._finishPromise})(u,v)}function g(){return(function(v){const p=v._transformStreamController;if(p._finishPromise!==void 0)return p._finishPromise;const E=v._readable;p._finishPromise=C((z,D)=>{p._finishPromise_resolve=z,p._finishPromise_reject=D});const m=p._flushAlgorithm();return ct(p),x(m,()=>(E._state==="errored"?Re(p,E._storedError):(ve(E._readableStreamController),$t(p)),null),z=>(M(E._readableStreamController,z),Re(p,z),null)),p._finishPromise})(u)}function q(){return(function(v){return yt(v,!1),v._backpressureChangePromise})(u)}function w(v){return(function(p,E){const m=p._transformStreamController;if(m._finishPromise!==void 0)return m._finishPromise;const z=p._writable;m._finishPromise=C((B,jt)=>{m._finishPromise_resolve=B,m._finishPromise_reject=jt});const D=m._cancelAlgorithm(E);return ct(m),x(D,()=>(z._state==="errored"?Re(m,z._storedError):(Me(z._writableStreamController,E),nr(p),$t(m)),null),B=>(Me(z._writableStreamController,B),nr(p),Re(m,B),null)),m._finishPromise})(u,v)}u._writable=(function(v,p,E,m,z=1,D=()=>1){const B=Object.create(te.prototype);return An(B),Xn(B,Object.create(Ae.prototype),v,p,E,m,z,D),B})(y,R,g,I,P,O),u._readable=Ye(y,q,w,F,k),u._backpressure=void 0,u._backpressureChangePromise=void 0,u._backpressureChangePromise_resolve=void 0,yt(u,!0),u._transformStreamController=void 0})(this,C(u=>{_=u}),c,f,a,l),(function(u,b){const P=Object.create(_e.prototype);let O,F,k;O=b.transform!==void 0?y=>b.transform(y,P):y=>{try{return so(P,y),T(void 0)}catch(R){return h(R)}},F=b.flush!==void 0?()=>b.flush(P):()=>T(void 0),k=b.cancel!==void 0?y=>b.cancel(y):()=>T(void 0),(function(y,R,I,g,q){R._controlledTransformStream=y,y._transformStreamController=R,R._transformAlgorithm=I,R._flushAlgorithm=g,R._cancelAlgorithm=q,R._finishPromise=void 0,R._finishPromise_resolve=void 0,R._finishPromise_reject=void 0})(u,P,O,F,k)})(this,s),s.start!==void 0?_(s.start(this._transformStreamController)):_(void 0)}get readable(){if(!Hr(this))throw Kr("readable");return this._readable}get writable(){if(!Hr(this))throw Kr("writable");return this._writable}};function Hr(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")&&e instanceof gt}function io(e,t){M(e._readable._readableStreamController,t),Or(e,t)}function Or(e,t){ct(e._transformStreamController),Me(e._writable._writableStreamController,t),nr(e)}function nr(e){e._backpressure&&yt(e,!1)}function yt(e,t){e._backpressureChangePromise!==void 0&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=C(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=t}Object.defineProperties(gt.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(gt.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});class _e{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!rt(this))throw nt("desiredSize");return zr(this._controlledTransformStream._readable._readableStreamController)}enqueue(t=void 0){if(!rt(this))throw nt("enqueue");so(this,t)}error(t=void 0){if(!rt(this))throw nt("error");var r;r=t,io(this._controlledTransformStream,r)}terminate(){if(!rt(this))throw nt("terminate");(function(t){const r=t._controlledTransformStream;ve(r._readable._readableStreamController);const n=new TypeError("TransformStream terminated");Or(r,n)})(this)}}function rt(e){return!!L(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")&&e instanceof _e}function ct(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0,e._cancelAlgorithm=void 0}function so(e,t){const r=e._controlledTransformStream,n=r._readable._readableStreamController;if(!Be(n))throw new TypeError("Readable side is not in a state that permits enqueue");try{je(n,t)}catch(i){throw Or(r,i),r._readable._storedError}(function(i){return!ro(i)})(n)!==r._backpressure&&yt(r,!0)}function Gr(e,t){return X(e._transformAlgorithm(t),void 0,r=>{throw io(e._controlledTransformStream,r),r})}function nt(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function $t(e){e._finishPromise_resolve!==void 0&&(e._finishPromise_resolve(),e._finishPromise_resolve=void 0,e._finishPromise_reject=void 0)}function Re(e,t){e._finishPromise_reject!==void 0&&(ke(e._finishPromise),e._finishPromise_reject(t),e._finishPromise_resolve=void 0,e._finishPromise_reject=void 0)}function Kr(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(_e.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),S(_e.prototype.enqueue,"enqueue"),S(_e.prototype.error,"error"),S(_e.prototype.terminate,"terminate"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(_e.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});const Ee=globalThis;let Cr=W,Ct=te,ao=gt;Ee.ReadableStream&&Ee.WritableStream&&Ee.TransformStream&&(Cr=Ee.ReadableStream,Ct=Ee.WritableStream,ao=Ee.TransformStream);const{console:Xr}=globalThis;var nn;const $o=((nn=Xr.createTask)==null?void 0:nn.bind(Xr))??(()=>({run(e){return e()}}));class lo{constructor(t){d(this,"task");d(this,"resolver");d(this,"value");d(this,"consumed");this.task=$o("Consumable"),this.value=t,this.resolver=new on,this.consumed=this.resolver.promise}consume(){this.resolver.resolve()}error(t){this.resolver.reject(t)}async tryConsume(t){try{const r=await this.task.run(()=>t(this.value));return this.consume(),r}catch(r){throw this.resolver.reject(r),r}}}async function Uo(e,t){const r=new lo(t);e.enqueue(r),await r.consumed}class Ao extends Ct{static async write(t,r){const n=new lo(r);await t.write(n),await n.consumed}constructor(t,r){let n;r&&(n={},"highWaterMark"in r&&(n.highWaterMark=r.highWaterMark),"size"in r&&(n.size=o=>r.size(o.value))),super({start(){var o;return(o=t.start)==null?void 0:o.call(t)},async write(o){await o.tryConsume(i=>{var s;return(s=t.write)==null?void 0:s.call(t,i)}),o.consume()},abort(o){var i;return(i=t.abort)==null?void 0:i.call(t,o)},close(){var o;return(o=t.close)==null?void 0:o.call(t)}},n)}}class Mo extends ao{constructor(t){let r;super({async start(n){var o;r={async enqueue(i){await Uo(n,i)},close(){n.terminate()},error(i){n.error(i)}},await((o=t.start)==null?void 0:o.call(t,r))},async transform(n){await n.tryConsume(o=>{var i;return(i=t.transform)==null?void 0:i.call(t,o,r)}),n.consume()},async flush(){var n;await((n=t.flush)==null?void 0:n.call(t,r))}})}}class Lr{constructor(t){d(this,"TValue");d(this,"TOmitInitKey");d(this,"options");this.options=t}}class Se{constructor(t,r,n,o){d(this,"definition");d(this,"options");d(this,"struct");d(this,"value");this.definition=t,this.options=r,this.struct=n,this.value=o}get hasCustomAccessors(){return this.get!==Se.prototype.get||this.set!==Se.prototype.set}getSize(){return this.definition.getSize()}get(){return this.value}set(t){this.value=t}}const Vo={littleEndian:!1},or=Symbol("struct-value");class Zr{constructor(t){d(this,"fieldValues",{});d(this,"value");this.value=Object.create(t),Object.defineProperty(this.value,or,{enumerable:!1,value:this})}set(t,r){this.fieldValues[t]=r,r.hasCustomAccessors?Object.defineProperty(this.value,t,{configurable:!0,enumerable:!0,get(){return r.get()},set(n){r.set(n)}}):this.value[t]=r.get()}get(t){return this.fieldValues[t]}}const se={reject(e){return new Qr(e)},resolve(e){return typeof e=="object"&&e!==null&&typeof e.then=="function"?e instanceof wt||e instanceof Jr||e instanceof Qr?e:new wt(e):new Jr(e)},try(e){try{return se.resolve(e())}catch(t){return se.reject(t)}}};class wt{constructor(t){d(this,"promise");this.promise=t}then(t,r){return new wt(this.promise.then(t,r))}valueOrPromise(){return this.promise}}class Jr{constructor(t){d(this,"value");this.value=t}then(t){return t?se.try(()=>t(this.value)):this}valueOrPromise(){return this.value}}class Qr{constructor(t){d(this,"reason");this.reason=t}then(t,r){return r?se.try(()=>r(this.reason)):this}valueOrPromise(){throw this.reason}}const Lt=BigInt(32);function Yo(e,t,r){const n=+!!r,o=+!r;return BigInt(e.getInt32(t,r)*o+e.getInt32(t+4,r)*n)<<Lt|BigInt(e.getUint32(t,r)*n+e.getUint32(t+4,r)*o)}function Ho(e,t,r){const n=e.getUint32(t,r),o=e.getUint32(t+4,r),i=+!!r,s=+!r;return BigInt(n*s+o*i)<<Lt|BigInt(n*i+o*s)}function Go(e,t,r,n){const o=Number(r>>Lt),i=Number(r&BigInt(4294967295));n?(e.setInt32(t+4,o,n),e.setUint32(t,i,n)):(e.setInt32(t,o,n),e.setUint32(t+4,i,n))}function Ko(e,t,r,n){const o=Number(r>>Lt),i=Number(r&BigInt(4294967295));n?(e.setUint32(t+4,o,n),e.setUint32(t,i,n)):(e.setUint32(t,o,n),e.setUint32(t+4,i,n))}const Xo="getBigInt64"in DataView.prototype?(e,t,r)=>e.getBigInt64(t,r):Yo,Zo="getBigUint64"in DataView.prototype?(e,t,r)=>e.getBigUint64(t,r):Ho,Jo="setBigInt64"in DataView.prototype?(e,t,r,n)=>e.setBigInt64(t,r,n):Go,Qo="setBigUint64"in DataView.prototype?(e,t,r,n)=>e.setBigUint64(t,r,n):Ko,qe=class qe{constructor(t,r,n){d(this,"TTypeScriptType");d(this,"size");d(this,"getter");d(this,"setter");this.size=t,this.getter=r,this.setter=n}};d(qe,"Int64",new qe(8,Xo,Jo)),d(qe,"Uint64",new qe(8,Zo,Qo));let vt=qe;class ei extends Lr{constructor(r,n){super();d(this,"type");this.type=r}getSize(){return this.type.size}create(r,n,o){return new ti(this,r,n,o)}deserialize(r,n,o){return se.try(()=>n.read(this.getSize())).then(i=>{const s=new DataView(i.buffer,i.byteOffset,i.byteLength),a=this.type.getter(s,0,r.littleEndian);return this.create(r,o,a)}).valueOrPromise()}}class ti extends Se{serialize(t,r){this.definition.type.setter(t,r,this.value,this.options.littleEndian)}}const{TextEncoder:ri,TextDecoder:ni}=globalThis,oi=new ri,ii=new ni;function si(e){return oi.encode(e)}function ai(e){return ii.decode(e)}class uo{constructor(){d(this,"TTypeScriptType")}}const Tt=class Tt extends uo{constructor(){super()}toBuffer(t){return t}toValue(t){return t}getSize(t){return t.byteLength}};d(Tt,"Instance",new Tt);let ir=Tt;const Rt=class Rt extends uo{toBuffer(t){return si(t)}toValue(t){return ai(t)}getSize(){return-1}};d(Rt,"Instance",new Rt);let sr=Rt;const ar=new Uint8Array(0);class co extends Lr{constructor(r,n){super(n);d(this,"type");this.type=r}getDeserializeSize(r){return this.getSize()}create(r,n,o,i){return new fo(this,r,n,o,i)}deserialize(r,n,o){return se.try(()=>{const i=this.getDeserializeSize(o);return i===0?ar:n.read(i)}).then(i=>{const s=this.type.toValue(i);return this.create(r,o,s,i)}).valueOrPromise()}}class fo extends Se{constructor(r,n,o,i,s){super(r,n,o,i);d(this,"array");this.array=s}set(r){super.set(r),this.array=void 0}serialize(r,n){this.array||(this.array=this.definition.type.toBuffer(this.value)),new Uint8Array(r.buffer,r.byteOffset,r.byteLength).set(this.array,n)}}class li extends co{getSize(){return this.options.length}}class ui extends co{getSize(){return 0}getDeserializeSize(t){let r=t.value[this.options.lengthField];return typeof r=="string"&&(r=Number.parseInt(r,this.options.lengthFieldRadix??10)),r}create(t,r,n,o){return new ci(this,t,r,n,o)}}class ci extends fo{constructor(r,n,o,i,s){super(r,n,o,i,s);d(this,"length");d(this,"lengthFieldValue");s&&(this.length=s.byteLength);const a=this.definition.options.lengthField,l=o.get(a);this.lengthFieldValue=new di(l,this),o.set(a,this.lengthFieldValue)}getSize(){return this.length===void 0&&(this.length=this.definition.type.getSize(this.value),this.length===-1&&(this.array=this.definition.type.toBuffer(this.value),this.length=this.array.byteLength)),this.length}set(r){super.set(r),this.array=void 0,this.length=void 0}}class di extends Se{constructor(r,n){super(r.definition,r.options,r.struct,0);d(this,"originalField");d(this,"bufferField");this.originalField=r,this.bufferField=n}getSize(){return this.originalField.getSize()}get(){let r=this.bufferField.getSize();return typeof this.originalField.get()=="string"&&(r=r.toString(this.bufferField.definition.options.lengthFieldRadix??10)),r}set(){}serialize(r,n){this.originalField.set(this.get()),this.originalField.serialize(r,n)}}var H;(function(e){e.Uint8={signed:!1,size:1,deserialize(t){return t[0]},serialize(t,r,n){t.setUint8(r,n)}},e.Int8={signed:!0,size:1,deserialize(t){return e.Uint8.deserialize(t,!1)<<24>>24},serialize(t,r,n){t.setInt8(r,n)}},e.Uint16={signed:!1,size:2,deserialize(t,r){return(t[1]<<8|t[0])*r|(t[0]<<8|t[1])*!r},serialize(t,r,n,o){t.setUint16(r,n,o)}},e.Int16={signed:!0,size:2,deserialize(t,r){return e.Uint16.deserialize(t,r)<<16>>16},serialize(t,r,n,o){t.setInt16(r,n,o)}},e.Uint32={signed:!1,size:4,deserialize(t,r){return e.Int32.deserialize(t,r)>>>0},serialize(t,r,n,o){t.setUint32(r,n,o)}},e.Int32={signed:!0,size:4,deserialize(t,r){return(t[3]<<24|t[2]<<16|t[1]<<8|t[0])*r|(t[0]<<24|t[1]<<16|t[2]<<8|t[3])*!r},serialize(t,r,n,o){t.setInt32(r,n,o)}}})(H=H||(H={}));class fi extends Lr{constructor(r,n){super();d(this,"type");this.type=r}getSize(){return this.type.size}create(r,n,o){return new hi(this,r,n,o)}deserialize(r,n,o){return se.try(()=>n.read(this.getSize())).then(i=>{const s=this.type.deserialize(i,r.littleEndian);return this.create(r,o,s)}).valueOrPromise()}}class hi extends Se{serialize(t,r){this.definition.type.serialize(t,r,this.value,this.options.littleEndian)}}class j{constructor(t){d(this,"TFields");d(this,"TOmitInitKey");d(this,"TExtra");d(this,"TInit");d(this,"TDeserializeResult");d(this,"options");d(this,"_size",0);d(this,"_fields",[]);d(this,"_extra",{});d(this,"_postDeserialized");d(this,"arrayBufferLike",(t,r,n)=>"length"in n?this.field(t,new li(r,n)):this.field(t,new ui(r,n)));d(this,"uint8Array",(t,r,n)=>this.arrayBufferLike(t,ir.Instance,r,n));d(this,"string",(t,r,n)=>this.arrayBufferLike(t,sr.Instance,r,n));this.options={...Vo,...t}}get size(){return this._size}field(t,r){for(const o of this._fields)if(o[0]===t)throw new Error(`This struct already have a field with name '${String(t)}'`);this._fields.push([t,r]);const n=r.getSize();return this._size+=n,this}fields(t){for(const r of t._fields)this._fields.push(r);return this._size+=t._size,Object.defineProperties(this._extra,Object.getOwnPropertyDescriptors(t._extra)),this}number(t,r,n){return this.field(t,new fi(r,n))}int8(t,r){return this.number(t,H.Int8,r)}uint8(t,r){return this.number(t,H.Uint8,r)}int16(t,r){return this.number(t,H.Int16,r)}uint16(t,r){return this.number(t,H.Uint16,r)}int32(t,r){return this.number(t,H.Int32,r)}uint32(t,r){return this.number(t,H.Uint32,r)}bigint(t,r,n){return this.field(t,new ei(r,n))}int64(t,r){return this.bigint(t,vt.Int64,r)}uint64(t,r){return this.bigint(t,vt.Uint64,r)}extra(t){return Object.defineProperties(this._extra,Object.getOwnPropertyDescriptors(t)),this}postDeserialize(t){return this._postDeserialized=t,this}deserialize(t){const r=new Zr(this._extra);let n=se.resolve();for(const[o,i]of this._fields)n=n.then(()=>i.deserialize(this.options,t,r)).then(s=>{r.set(o,s)});return n.then(()=>{const o=r.value;if(this._postDeserialized){const i=this._postDeserialized.call(o,o);if(i!==void 0)return i}return o}).valueOrPromise()}serialize(t,r){let n;if(or in t){n=t[or];for(const[c,f]of Object.entries(t)){const _=n.get(c);_&&_.set(f)}}else{n=new Zr({});for(const[c,f]of this._fields){const _=f.create(this.options,n,t[c]);n.set(c,_)}}let o=0;const i=[];for(const[c]of this._fields){const f=n.get(c),_=f.getSize();i.push({fieldValue:f,size:_}),o+=_}let s="number";r||(r=new Uint8Array(o),s="Uint8Array");const a=new DataView(r.buffer,r.byteOffset,r.byteLength);let l=0;for(const{fieldValue:c,size:f}of i)c.serialize(a,l),l+=f;return s==="number"?o:r}}function _i(e,t){return"start"in e?e.start(t):typeof e=="function"?e(t):e}class bi extends Cr{constructor(r){super({start:async n=>{await Promise.resolve(),this.readable=await _i(r,n),this.reader=this.readable.getReader()},cancel:async n=>{var o;await this.reader.cancel(n),"cancel"in r&&await((o=r.cancel)==null?void 0:o.call(r,n))},pull:async n=>{var i;const o=await this.reader.read();o.done?(n.close(),"close"in r&&await((i=r.close)==null?void 0:i.call(r))):n.enqueue(o.value)}});d(this,"readable");d(this,"reader")}}const en=()=>{};class pi{constructor(t){d(this,"readableControllers",[]);d(this,"writers",[]);d(this,"_writableClosed",!1);d(this,"_closed",new on);d(this,"options");this.options=t??{}}get writableClosed(){return this._writableClosed}get closed(){return this._closed.promise}wrapReadable(t){return new bi({start:r=>(this.readableControllers.push(r),t),cancel:async()=>{await this.close()},close:async()=>{await this.dispose()}})}createWritable(t){const r=t.getWriter();return this.writers.push(r),new Ct({write:async n=>{await r.write(n)},abort:async n=>{await r.abort(n),await this.close()},close:async()=>{await r.close().catch(en),await this.close()}})}async close(){var t,r;if(!this._writableClosed){this._writableClosed=!0,await((r=(t=this.options).close)==null?void 0:r.call(t))!==!1&&await this.dispose();for(const n of this.writers)await n.close().catch(en)}}async dispose(){var t,r;this._writableClosed=!0,this._closed.resolve();for(const n of this.readableControllers)try{n.close()}catch{}await((r=(t=this.options).dispose)==null?void 0:r.call(t))}}function mi(e,t){const r=t.writable.getWriter(),n=t.readable.pipeTo(e);return new Ct({async write(o){await r.write(o)},async close(){await r.close(),await n}})}BigInt(0);BigInt(1);BigInt(2);BigInt(64);var Ut;(function(e){e[e.Auth=1213486401]="Auth",e[e.Close=1163086915]="Close",e[e.Connect=1314410051]="Connect",e[e.OK=1497451343]="OK",e[e.Open=1313165391]="Open",e[e.Write=1163154007]="Write"})(Ut=Ut||(Ut={}));const St=new j({littleEndian:!0}).uint32("command").uint32("arg0").uint32("arg1").uint32("payloadLength").uint32("checksum").int32("magic");new j({littleEndian:!0}).fields(St).uint8Array("payload",{lengthField:"payloadLength"});class gi extends Mo{constructor(){const t=new Uint8Array(St.size);super({transform:async(r,n)=>{const o=r;o.payloadLength=o.payload.byteLength,St.serialize(o,t),await n.enqueue(t),o.payload.byteLength&&await n.enqueue(o.payload)}})}}function Ke(e,t){e.charCodeAt(0),t.charCodeAt(0)}Ke("A","Z");Ke("a","z");Ke("0","9");Ke("+","+");Ke("/","/");var At;(function(e){e[e.Token=1]="Token",e[e.Signature=2]="Signature",e[e.PublicKey=3]="PublicKey"})(At=At||(At={}));new j({littleEndian:!0}).uint32("version");new j({littleEndian:!0}).uint32("bpp").uint32("size").uint32("width").uint32("height").uint32("red_offset").uint32("red_length").uint32("blue_offset").uint32("blue_length").uint32("green_offset").uint32("green_length").uint32("alpha_offset").uint32("alpha_length").uint8Array("data",{lengthField:"size"});new j({littleEndian:!0}).uint32("bpp").uint32("colorSpace").uint32("size").uint32("width").uint32("height").uint32("red_offset").uint32("red_length").uint32("blue_offset").uint32("blue_length").uint32("green_offset").uint32("green_length").uint32("alpha_offset").uint32("alpha_length").uint8Array("data",{lengthField:"size"});const yi=new j().string("length",{length:4}).string("content",{lengthField:"length",lengthFieldRadix:16});class jr extends Error{constructor(t){super(t),Object.setPrototypeOf(this,jr.prototype)}}class Br extends Error{constructor(){super("ADB reverse tunnel is not supported on this device when connected wirelessly."),Object.setPrototypeOf(this,Br.prototype)}}new j().fields(yi).postDeserialize(e=>{throw e.content==="more than one device/emulator"?new Br:new jr(e.content)});var Mt;(function(e){e.ShellV2="shell_v2",e.Cmd="cmd",e.StatV2="stat_v2",e.ListV2="ls_v2",e.FixedPushMkdir="fixed_push_mkdir",e.Abb="abb",e.AbbExec="abb_exec",e.SendReceiveV2="sendrecv_v2"})(Mt=Mt||(Mt={}));var Vt;(function(e){e[e.Stdin=0]="Stdin",e[e.Stdout=1]="Stdout",e[e.Stderr=2]="Stderr",e[e.Exit=3]="Exit",e[e.CloseStdin=4]="CloseStdin",e[e.WindowSizeChange=5]="WindowSizeChange"})(Vt=Vt||(Vt={}));new j({littleEndian:!0}).uint8("id",void 0).uint32("length").uint8Array("data",{lengthField:"length"});var Yt;(function(e){e.List="LIST",e.ListV2="LIS2",e.Send="SEND",e.SendV2="SND2",e.Lstat="STAT",e.Stat="STA2",e.LstatV2="LST2",e.Data="DATA",e.Done="DONE",e.Receive="RECV"})(Yt=Yt||(Yt={}));const wi=new j({littleEndian:!0}).string("id",{length:4}).uint32("arg");new j({littleEndian:!0}).fields(wi).uint8Array("data",{lengthField:"arg"});var ie;(function(e){e.Entry="DENT",e.Entry2="DNT2",e.Lstat="STAT",e.Stat="STA2",e.Lstat2="LST2",e.Done="DONE",e.Data="DATA",e.Ok="OKAY",e.Fail="FAIL"})(ie=ie||(ie={}));new j({littleEndian:!0}).uint32("messageLength").string("message",{lengthField:"messageLength"}).postDeserialize(e=>{throw new Error(e.message)});var Ht;(function(e){e[e.Directory=4]="Directory",e[e.File=8]="File",e[e.Link=10]="Link"})(Ht=Ht||(Ht={}));const vi=new j({littleEndian:!0}).int32("mode").int32("size").int32("mtime").extra({id:ie.Lstat,get type(){return this.mode>>12},get permission(){return this.mode&4095}}).postDeserialize(e=>{if(e.mode===0&&e.size===0&&e.mtime===0)throw new Error("lstat error")});var dt;(function(e){e[e.SUCCESS=0]="SUCCESS",e[e.EACCES=13]="EACCES",e[e.EEXIST=17]="EEXIST",e[e.EFAULT=14]="EFAULT",e[e.EFBIG=27]="EFBIG",e[e.EINTR=4]="EINTR",e[e.EINVAL=22]="EINVAL",e[e.EIO=5]="EIO",e[e.EISDIR=21]="EISDIR",e[e.ELOOP=40]="ELOOP",e[e.EMFILE=24]="EMFILE",e[e.ENAMETOOLONG=36]="ENAMETOOLONG",e[e.ENFILE=23]="ENFILE",e[e.ENOENT=2]="ENOENT",e[e.ENOMEM=12]="ENOMEM",e[e.ENOSPC=28]="ENOSPC",e[e.ENOTDIR=20]="ENOTDIR",e[e.EOVERFLOW=75]="EOVERFLOW",e[e.EPERM=1]="EPERM",e[e.EROFS=30]="EROFS",e[e.ETXTBSY=26]="ETXTBSY"})(dt=dt||(dt={}));const Si=new j({littleEndian:!0}).uint32("error",void 0).uint64("dev").uint64("ino").uint32("mode").uint32("nlink").uint32("uid").uint32("gid").uint64("size").uint64("atime").uint64("mtime").uint64("ctime").extra({id:ie.Stat,get type(){return this.mode>>12},get permission(){return this.mode&4095}}).postDeserialize(e=>{if(e.error)throw new Error(dt[e.error])});new j({littleEndian:!0}).fields(vi).uint32("nameLength").string("name",{lengthField:"nameLength"}).extra({id:ie.Entry});new j({littleEndian:!0}).fields(Si).uint32("nameLength").string("name",{lengthField:"nameLength"}).extra({id:ie.Entry2});new j({littleEndian:!0}).uint32("dataLength").uint8Array("data",{lengthField:"dataLength"}).extra({id:ie.Data});new j({littleEndian:!0}).uint32("unused");var Gt;(function(e){e[e.None=0]="None",e[e.Brotli=1]="Brotli",e[e.Lz4=2]="Lz4",e[e.Zstd=4]="Zstd",e[e.DryRun=2147483648]="DryRun"})(Gt=Gt||(Gt={}));new j({littleEndian:!0}).uint32("id",void 0).uint32("mode").uint32("flags",void 0);var Kt;(function(e){e.Product="ro.product.name",e.Model="ro.product.model",e.Device="ro.product.device",e.Features="features"})(Kt=Kt||(Kt={}));const lr={classCode:255,subclassCode:66,protocolCode:1};function Ti(e,t){return t.some(r=>e.interfaceClass===r.classCode&&e.interfaceSubclass===r.subclassCode&&e.interfaceProtocol===r.protocolCode)}function Ri(e,t){for(const r of e.configurations)for(const n of r.interfaces)for(const o of n.alternates)if(Ti(o,t))return{configuration:r,interface_:n,alternate:o};throw new Error("No matched alternate interface found")}function Ei(e){if(e.length===0)throw new Error("No endpoints given");let t,r;for(const n of e)switch(n.direction){case"in":if(t=n,r)return{inEndpoint:t,outEndpoint:r};break;case"out":if(r=n,t)return{inEndpoint:t,outEndpoint:r};break}throw t?r?new Error("unreachable"):new Error("No output endpoint found."):new Error("No input endpoint found.")}class Pi{constructor(t){d(this,"buffer");d(this,"offset");this.buffer=t,this.offset=0}read(t){const r=this.buffer.subarray(this.offset,this.offset+t);return this.offset+=t,r}}class zi{constructor(t,r,n,o){d(this,"_readable");d(this,"_writable");let i=!1;const s=new pi({close:async()=>{try{i=!0,await t.close()}catch{}},dispose:()=>{o.removeEventListener("disconnect",a)}});function a(c){c.device===t&&s.dispose().catch(f=>{})}o.addEventListener("disconnect",a),this._readable=s.wrapReadable(new Cr({async pull(c){const f=await t.transferIn(r.endpointNumber,24),_=new Uint8Array(f.data.buffer),u=new Pi(_),b=St.deserialize(u);if(b.payloadLength!==0){const P=await t.transferIn(r.endpointNumber,b.payloadLength);b.payload=new Uint8Array(P.data.buffer)}else b.payload=ar;c.enqueue(b)}}));const l=n.packetSize-1;this._writable=mi(s.createWritable(new Ao({write:async c=>{try{await t.transferOut(n.endpointNumber,c),l&&(c.byteLength&l)===0&&await t.transferOut(n.endpointNumber,ar)}catch(f){if(i)return;throw f}}})),new gi)}get readable(){return this._readable}get writable(){return this._writable}}class tn{constructor(t,r=[lr],n){d(this,"_filters");d(this,"_usb");d(this,"_device");this._device=t,this._filters=r,this._usb=n}get device(){return this._device}get serial(){return this._device.serialNumber}get name(){return this._device.productName}async connect(){var s;this._device.opened||await this._device.open();const{configuration:t,interface_:r,alternate:n}=Ri(this._device,this._filters);((s=this._device.configuration)==null?void 0:s.configurationValue)!==t.configurationValue&&await this._device.selectConfiguration(t.configurationValue),r.claimed||await this._device.claimInterface(r.interfaceNumber),r.alternate.alternateSetting!==n.alternateSetting&&await this._device.selectAlternateInterface(r.interfaceNumber,n.alternateSetting);const{inEndpoint:o,outEndpoint:i}=Ei(n.endpoints);return new zi(this._device,o,i,this._usb)}}const Et=class Et{constructor(t){d(this,"_usb");this._usb=t}async requestDevice(t=[lr]){try{const r=await this._usb.requestDevice({filters:t});return new tn(r,t,this._usb)}catch(r){if(typeof r=="object"&&r!==null&&"name"in r&&r.name==="NotFoundError")return;throw r}}async getDevices(t=[lr]){return(await this._usb.getDevices()).map(n=>new tn(n,t,this._usb))}};d(Et,"BROWSER",typeof window<"u"&&window.navigator.usb?new Et(window.navigator.usb):void 0);let rn=Et;class ji{constructor(t,r){d(this,"_callback");d(this,"_usb");d(this,"handleConnect",t=>{this._callback(t.device.serialNumber)});d(this,"handleDisconnect",()=>{this._callback()});this._callback=t,this._usb=r,this._usb.addEventListener("connect",this.handleConnect),this._usb.addEventListener("disconnect",this.handleDisconnect)}dispose(){this._usb.removeEventListener("connect",this.handleConnect),this._usb.removeEventListener("disconnect",this.handleDisconnect)}}export{lr as ADB_DEFAULT_DEVICE_FILTER,tn as AdbWebUsbBackend,rn as AdbWebUsbBackendManager,zi as AdbWebUsbBackendStream,ji as AdbWebUsbBackendWatcher};
