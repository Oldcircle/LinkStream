var w=e=>{throw TypeError(e)};var f=(e,r,t)=>r.has(e)||w("Cannot "+t);var l=(e,r,t)=>(f(e,r,"read from private field"),t?t.call(e):r.get(e)),u=(e,r,t)=>r.has(e)?w("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(e):r.set(e,t),d=(e,r,t,n)=>(f(e,r,"write to private field"),n?n.call(e,t):r.set(e,t),t);import{A as v}from"./sticky-event-emitter-B3ySTSV4.js";import{B as y,h as E,s as T,n as g,e as R,d as p}from"./struct-deserialize-DCusmjXY.js";function K(e){return new Promise(r=>{globalThis.setTimeout(()=>r(),e)})}const x=globalThis,P=x.TextDecoderStream;var c;class S extends v{constructor(t){super();u(this,c);d(this,c,t)}get adb(){return l(this,c)}}c=new WeakMap;function N(e){if(e<48)throw new TypeError(`Invalid hex char ${e}`);if(e<58)return e-48;if(e<65)throw new TypeError(`Invalid hex char ${e}`);if(e<71)return e-55;if(e<97)throw new TypeError(`Invalid hex char ${e}`);if(e<103)return e-87;throw new TypeError(`Invalid hex char ${e}`)}function $(e){let r=0;for(let t=0;t<e.length;t+=1)r=r<<4|N(e[t]);return r}function U(e,r,t){const n=r;for(r+=3;r>=n&&t>0;){const s=t&15;t>>=4,s<10?e[r]=s+48:e[r]=s+87,r-=1}for(;r>=n;)e[r]=48,r-=1}const Y=()=>{};function j(...e){throw new Error(`Unreachable. Arguments:
`+e.join(`
`))}function B(e,r){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t+=1)if(e[t]!==r[t])return!1;return!0}const m=T({length:p(4),content:p({field:"length",convert(e){return Number.parseInt(e,16)},back(e){return e.toString(16).padStart(4,"0")}})},{littleEndian:!0});class b extends Error{constructor(r){super(r)}}class q extends b{constructor(){super("ADB reverse tunnel is not supported on this device when connected wirelessly.")}}const A=E(m,{},{postDeserialize(e){throw e.content==="more than one device/emulator"?new q:new b(e.content)}});function D(e){let r=0;for(const t of e){if(t<48||t>57)return r;r=r*10+t-48}return r}const k=R("OKAY");var o;class C extends S{constructor(){super(...arguments);u(this,o,new Map)}async createBufferedStream(t){const n=await this.adb.createSocket(t);return new y(n.readable)}async sendRequest(t){const n=await this.createBufferedStream(t),s=await n.readExactly(4);return B(s,k)||await A.deserialize(n),n}async list(){const t=await this.createBufferedStream("reverse:list-forward");return(await m.deserialize(t)).content.split(`
`).filter(s=>!!s).map(s=>{const[i,a,h]=s.split(" ");return{deviceSerial:i,localName:a,remoteName:h}})}async addExternal(t,n){const s=await this.sendRequest(`reverse:forward:${t};${n}`);if(t.startsWith("tcp:")){const i=s.position;try{const a=$(await s.readExactly(4));t=`tcp:${D(await s.readExactly(a))}`}catch(a){if(!(a instanceof g&&s.position===i))throw a}}return t}async add(t,n,s){s=await this.adb.transport.addReverseTunnel(n,s);try{return t=await this.addExternal(t,s),l(this,o).set(t,s),t}catch(i){throw await this.adb.transport.removeReverseTunnel(s),i}}async remove(t){const n=l(this,o).get(t);n&&await this.adb.transport.removeReverseTunnel(n),await this.sendRequest(`reverse:killforward:${t}`)}async removeAll(){await this.adb.transport.clearReverseTunnels(),l(this,o).clear(),await this.sendRequest("reverse:killforward-all")}}o=new WeakMap;export{S as A,Y as N,P as T,C as a,b,q as c,K as d,$ as h,B as s,j as u,U as w};
