var ms=Object.defineProperty;var Cr=s=>{throw TypeError(s)};var Ss=(s,e,t)=>e in s?ms(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var f=(s,e,t)=>Ss(s,typeof e!="symbol"?e+"":e,t),tr=(s,e,t)=>e.has(s)||Cr("Cannot "+t);var n=(s,e,t)=>(tr(s,e,"read from private field"),t?t.call(s):e.get(s)),c=(s,e,t)=>e.has(s)?Cr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(s):e.set(s,t),l=(s,e,t,r)=>(tr(s,e,"write to private field"),r?r.call(s,t):e.set(s,t),t),b=(s,e,t)=>(tr(s,e,"access private method"),t);import{P as A,W as Ce,R as pr,T as Wr,g as Qt,A as Jt,s as vs}from"./stream-CeehbguB.js";import{E as ae,C as G,s as D,b as Lt,u as d,B as gr,S as Es,a as As,P as Ut,c as $r,e as se,d as mr,f as Nt,g as Te,h as Sr,i as ks,j as xs,k as Cs,t as Ts,l as Ps,T as Is,m as Ds}from"./struct-deserialize-DCusmjXY.js";import{A as Mr,T as Vt,u as _s,N as Rs,a as Ls,d as Ns,s as nr,w as Os,h as Bt}from"./reverse-DeNl7JEN.js";import{b as yi,c as bi}from"./reverse-DeNl7JEN.js";import{E as Tr,S as Pr}from"./sticky-event-emitter-B3ySTSV4.js";class Fs{constructor(e=0){f(this,"nextId");f(this,"pendingResolvers",new Map);this.nextId=e}add(){const e=this.nextId++,t=new A;return this.pendingResolvers.set(e,t),[e,t.promise]}getResolver(e){if(!this.pendingResolvers.has(e))return null;const t=this.pendingResolvers.get(e);return this.pendingResolvers.delete(e),t}resolve(e,t){const r=this.getResolver(e);return r!==null?(r.resolve(t),!0):!1}reject(e,t){const r=this.getResolver(e);return r!==null?(r.reject(t),!0):!1}}function zs(s,e,t){s[e]=Number(t&0xffn),s[e+1]=Number(t>>8n&0xffn),s[e+2]=Number(t>>16n&0xffn),s[e+3]=Number(t>>24n&0xffn),s[e+4]=Number(t>>32n&0xffn),s[e+5]=Number(t>>40n&0xffn),s[e+6]=Number(t>>48n&0xffn),s[e+7]=Number(t>>56n&0xffn)}function Us(s,e,t){s[e]=Number(t>>56n&0xffn),s[e+1]=Number(t>>48n&0xffn),s[e+2]=Number(t>>40n&0xffn),s[e+3]=Number(t>>32n&0xffn),s[e+4]=Number(t>>24n&0xffn),s[e+5]=Number(t>>16n&0xffn),s[e+6]=Number(t>>8n&0xffn),s[e+7]=Number(t&0xffn)}var Ie,_,Kt,ce,$e;class Wt{constructor(){c(this,Ie,"");c(this,_,new A);c(this,Kt,new Ce({write:e=>{l(this,Ie,n(this,Ie)+e)},close:()=>{n(this,_).resolve(n(this,Ie)),n(this,ce).enqueue(n(this,Ie)),n(this,ce).close()},abort:e=>{n(this,_).reject(e),n(this,ce).error(e)}}));c(this,ce);c(this,$e,new pr({start:e=>{l(this,ce,e)}}));Object.defineProperties(n(this,$e),{then:{get:()=>n(this,_).promise.then.bind(n(this,_).promise)},catch:{get:()=>n(this,_).promise.catch.bind(n(this,_).promise)},finally:{get:()=>n(this,_).promise.finally.bind(n(this,_).promise)}})}get writable(){return n(this,Kt)}get readable(){return n(this,$e)}}Ie=new WeakMap,_=new WeakMap,Kt=new WeakMap,ce=new WeakMap,$e=new WeakMap;var Y,R,Gt,le,Me;class ir{constructor(){c(this,Y,[]);c(this,R,new A);c(this,Gt,new Ce({write:e=>{n(this,Y).push(e)},close:()=>{let e,t=0;switch(n(this,Y).length){case 0:e=ae;break;case 1:e=n(this,Y)[0];break;default:e=new Uint8Array(n(this,Y).reduce((r,i)=>r+i.length,0));for(const r of n(this,Y))e.set(r,t),t+=r.length;break}n(this,R).resolve(e),n(this,le).enqueue(e),n(this,le).close()},abort:e=>{n(this,R).reject(e),n(this,le).error(e)}}));c(this,le);c(this,Me,new pr({start:e=>{l(this,le,e)}}));Object.defineProperties(n(this,Me),{then:{get:()=>n(this,R).promise.then.bind(n(this,R).promise)},catch:{get:()=>n(this,R).promise.catch.bind(n(this,R).promise)},finally:{get:()=>n(this,R).promise.finally.bind(n(this,R).promise)}})}get writable(){return n(this,Gt)}get readable(){return n(this,Me)}}Y=new WeakMap,R=new WeakMap,Gt=new WeakMap,le=new WeakMap,Me=new WeakMap;function jr(s,e){return s instanceof G?s.tryConsume(e):e(s)}class Ot extends Ce{constructor(e,t){let r;t&&(r={},"highWaterMark"in t&&(r.highWaterMark=t.highWaterMark),"size"in t&&(r.size=i=>t.size(i instanceof G?i.value:i))),super({start(i){var a;return(a=e.start)==null?void 0:a.call(e,i)},write(i,a){return jr(i,o=>{var h;return(h=e.write)==null?void 0:h.call(e,o,a)})},abort(i){var a;return(a=e.abort)==null?void 0:a.call(e,i)},close(){var i;return(i=e.close)==null?void 0:i.call(e)}},r)}}var M,j,x,C;class qr{constructor(e){c(this,M);c(this,j);c(this,x);c(this,C);l(this,M,e),l(this,j,new Uint8Array(e)),l(this,x,0),l(this,C,e)}*push(e){let t=0,r=e.length;if(n(this,x)!==0)if(r>=n(this,C)){if(n(this,j).set(e.subarray(0,n(this,C)),n(this,x)),t+=n(this,C),r-=n(this,C),yield n(this,j),l(this,x,0),l(this,C,n(this,M)),r===0)return}else{n(this,j).set(e,n(this,x)),l(this,x,n(this,x)+r),l(this,C,n(this,C)-r);return}for(;r>=n(this,M);){const i=t+n(this,M);yield e.subarray(t,i),t=i,r-=n(this,M)}r>0&&(n(this,j).set(e.subarray(t),n(this,x)),l(this,x,n(this,x)+r),l(this,C,n(this,C)-r))}flush(){if(n(this,x)===0)return;const e=n(this,j).subarray(0,n(this,x));return l(this,x,0),l(this,C,n(this,M)),e}}M=new WeakMap,j=new WeakMap,x=new WeakMap,C=new WeakMap;class Vs extends Wr{constructor(e,t=!1){const r=t?new qr(e):void 0;super({async transform(i,a){await jr(i,async o=>{if(r)for(const h of r.push(o))await G.ReadableStream.enqueue(a,h);else{let h=0,u=o.length;for(;u>0;){const w=h+e;await G.ReadableStream.enqueue(a,o.subarray(h,w)),h=w,u-=e}}})},flush(i){if(r){const a=r.flush();a&&i.enqueue(a)}}})}}const Bs=D({version:d},{littleEndian:!0}),Ws=D({bpp:d,size:d,width:d,height:d,red_offset:d,red_length:d,blue_offset:d,blue_length:d,green_offset:d,green_length:d,alpha_offset:d,alpha_length:d,data:Lt("size")},{littleEndian:!0}),$s=D({bpp:d,colorSpace:d,size:d,width:d,height:d,red_offset:d,red_length:d,blue_offset:d,blue_length:d,green_offset:d,green_length:d,alpha_offset:d,alpha_length:d,data:Lt("size")},{littleEndian:!0});class Kr extends Error{constructor(e,t){super(e,t)}}class Ms extends Kr{constructor(e){super(`Unsupported FrameBuffer version ${e}`)}}class js extends Kr{constructor(){super("FrameBuffer is disabled by current app")}}async function qs(s){const e=await s.createSocket("framebuffer:"),t=new gr(e.readable);let r;try{({version:r}=await Bs.deserialize(t))}catch(i){throw i instanceof Es?new js:i}switch(r){case 1:return await Ws.deserialize(t);case 2:return await $s.deserialize(t);default:throw new Ms(r)}}class Ks extends Mr{reboot(e=""){return this.adb.createSocketAndWait(`reboot:${e}`)}bootloader(){return this.reboot("bootloader")}fastboot(){return this.reboot("fastboot")}recovery(){return this.reboot("recovery")}sideload(){return this.reboot("sideload")}qualcommEdlMode(){return this.reboot("edl")}powerOff(){return this.adb.subprocess.noneProtocol.spawnWaitText(["reboot","-p"])}powerButton(e=!1){const t=["input","keyevent"];return e&&t.push("--longpress"),t.push("POWER"),this.adb.subprocess.noneProtocol.spawnWaitText(t)}samsungOdin(){return this.reboot("download")}}function li(s){if(s.buffer instanceof ArrayBuffer)return s;const e=new Uint8Array(s.length);return e.set(s),e}var he,q;class Gr{constructor(e=!1){c(this,he);c(this,q,[]);l(this,he,e)}wait(){if(!n(this,he)&&(l(this,he,!0),n(this,q).length===0))return Promise.resolve();const e=new A;return n(this,q).push(e),e.promise}notifyOne(){n(this,q).length!==0?n(this,q).pop().resolve():l(this,he,!1)}dispose(){for(const e of n(this,q))e.reject(new Error("The AutoResetEvent has been disposed"));n(this,q).length=0}}he=new WeakMap,q=new WeakMap;const[$,g,Pe]=(()=>{const s=[],e=[];function r(i,a){const o=i.charCodeAt(0),h=a.charCodeAt(0);for(let u=o;u<=h;u+=1)s[u]=e.length,e.push(u)}return r("A","Z"),r("a","z"),r("0","9"),r("+","+"),r("/","/"),[s,e,61]})();function Hr(s){const e=s%3,t=e!==0?3-e:0;return[(s+t)/3*4,t]}function Gs(s,e){const[t,r]=Hr(s.length);if(e){if(e.length<t)throw new TypeError("output buffer is too small");if(e=e.subarray(0,t),s.buffer!==e.buffer)rr(s,e,r);else if(e.byteOffset+e.length-(r+1)<=s.byteOffset+s.length)rr(s,e,r);else if(e.byteOffset>=s.byteOffset-1)Hs(s,e,r);else throw new TypeError("input and output cannot overlap");return t}else return e=new Uint8Array(t),rr(s,e,r),e}function rr(s,e,t){let r=0,i=0;for(;r<s.length-2;){const a=s[r];r+=1;const o=s[r];r+=1;const h=s[r];r+=1,e[i]=g[a>>2],i+=1,e[i]=g[(a&3)<<4|o>>4],i+=1,e[i]=g[(o&15)<<2|h>>6],i+=1,e[i]=g[h&63],i+=1}if(t===2){const a=s[r];r+=1,e[i]=g[a>>2],i+=1,e[i]=g[(a&3)<<4],i+=1,e[i]=Pe,i+=1,e[i]=Pe}else if(t===1){const a=s[r];r+=1;const o=s[r];r+=1,e[i]=g[a>>2],i+=1,e[i]=g[(a&3)<<4|o>>4],i+=1,e[i]=g[(o&15)<<2],i+=1,e[i]=Pe}}function Hs(s,e,t){let r=s.length-1,i=e.length-1;if(t===2){const a=s[r];r-=1,e[i]=Pe,i-=1,e[i]=Pe,i-=1,e[i]=g[(a&3)<<4],i-=1,e[i]=g[a>>2],i-=1}else if(t===1){const a=s[r];r-=1;const o=s[r];r-=1,e[i]=Pe,i-=1,e[i]=g[(a&15)<<2],i-=1,e[i]=g[(o&3)<<4|a>>4],i-=1,e[i]=g[o>>2],i-=1}for(;r>=0;){const a=s[r];r-=1;const o=s[r];r-=1;const h=s[r];r-=1,e[i]=g[a&63],i-=1,e[i]=g[(o&15)<<2|a>>6],i-=1,e[i]=g[(h&3)<<4|o>>4],i-=1,e[i]=g[h>>2],i-=1}}function hi(s){let e;s[s.length-2]==="="?e=2:s[s.length-1]==="="?e=1:e=0;const t=new Uint8Array(s.length/4*3-e);let r=0,i=0;for(;r<s.length-(e!==0?4:0);){const a=$[s.charCodeAt(r)];r+=1;const o=$[s.charCodeAt(r)];r+=1;const h=$[s.charCodeAt(r)];r+=1;const u=$[s.charCodeAt(r)];r+=1,t[i]=a<<2|(o&48)>>4,i+=1,t[i]=(o&15)<<4|(h&60)>>2,i+=1,t[i]=(h&3)<<6|u,i+=1}if(e===1){const a=$[s.charCodeAt(r)];r+=1;const o=$[s.charCodeAt(r)];r+=1;const h=$[s.charCodeAt(r)];t[i]=a<<2|(o&48)>>4,i+=1,t[i]=(o&15)<<4|(h&60)>>2}else if(e===2){const a=$[s.charCodeAt(r)];r+=1;const o=$[s.charCodeAt(r)];t[i]=a<<2|(o&48)>>4}return t}const{setInterval:Ys,clearInterval:Zs}=globalThis;var de;class Xs{constructor(e){c(this,de);e!=null&&e.unref||this.ref()}ref(){l(this,de,Ys(()=>{},60*1e3))}unref(){n(this,de)&&(Zs(n(this,de)),l(this,de,void 0))}}de=new WeakMap;var U,De;class Qs{constructor(e,t){c(this,U);c(this,De);if(l(this,U,e),t){const r=new A;n(this,U).closed.then(()=>r.resolve(void 0),i=>r.reject(i)),t.addEventListener("abort",()=>{r.reject(t.reason),n(this,U).close()}),l(this,De,r.promise)}else l(this,De,n(this,U).closed)}get stdin(){return n(this,U).writable}get output(){return n(this,U).readable}get exited(){return n(this,De)}kill(){return n(this,U).close()}}U=new WeakMap,De=new WeakMap;var Z,_e,je;class Js{constructor(e){c(this,Z);c(this,_e);c(this,je);l(this,Z,e),l(this,_e,n(this,Z).writable.getWriter()),l(this,je,new Ot({write:t=>n(this,_e).write(t)}))}get input(){return n(this,je)}get output(){return n(this,Z).readable}get exited(){return n(this,Z).closed}sigint(){return n(this,_e).write(new Uint8Array([3]))}kill(){return n(this,Z).close()}}Z=new WeakMap,_e=new WeakMap,je=new WeakMap;function ar(s){let e="";e+="'";let t=0;for(;;){const r=s.indexOf("'",t);if(r===-1){e+=s.substring(t);break}e+=s.substring(t,r),e+=String.raw`'\''`,t=r+1}return e+="'",e}function Yr(s){const e=[];let t,r=!1,i=0;for(let a=0,o=s.length;a<o;a+=1){if(r){r=!1;continue}const h=s.charAt(a);switch(h){case" ":!t&&a!==i&&(e.push(s.substring(i,a)),i=a+1);break;case"'":case'"':t?h===t&&(t=void 0):t=h;break;case"\\":r=!0;break}}return i<s.length&&e.push(s.substring(i)),e}var qe;class en{constructor(e){c(this,qe);l(this,qe,e)}spawn(e,t){return t==null||t.throwIfAborted(),typeof e=="string"&&(e=Yr(e)),n(this,qe).call(this,e,t)}async spawnWait(e){return await(await this.spawn(e)).output.pipeThrough(new ir)}async spawnWaitText(e){return await(await this.spawn(e)).output.pipeThrough(new Vt).pipeThrough(new Wt)}}qe=new WeakMap;var ue;class tn extends en{constructor(t){super(async(r,i)=>{const a=await n(this,ue).createSocket(`exec:${r.join(" ")}`);if(i!=null&&i.aborted)throw await a.close(),i.reason;return new Qs(a,i)});c(this,ue);l(this,ue,t)}get adb(){return n(this,ue)}async pty(t){return t===void 0?t="":Array.isArray(t)&&(t=t.join(" ")),new Js(await n(this,ue).createSocket(`shell:${t}`))}}ue=new WeakMap;const y={ShellV2:"shell_v2",Cmd:"cmd",StatV2:"stat_v2",ListV2:"ls_v2",FixedPushMkdir:"fixed_push_mkdir",Abb:"abb",AbbExec:"abb_exec",SendReceiveV2:"sendrecv_v2",DelayedAck:"delayed_ack"},re={Stdin:0,Stdout:1,Stderr:2,Exit:3,CloseStdin:4,WindowSizeChange:5},We=D({id:As(),data:Lt(d)},{littleEndian:!0});var we,Ke,Ge,He,Ye,Ze;class rn{constructor(e,t){c(this,we);c(this,Ke);c(this,Ge);c(this,He);c(this,Ye);c(this,Ze);l(this,we,e);let r,i;l(this,He,new Ut(o=>{r=o})),l(this,Ye,new Ut(o=>{i=o}));const a=new A;l(this,Ze,a.promise),e.readable.pipeThrough(new $r(We)).pipeTo(new Ce({write:async o=>{switch(o.id){case re.Exit:a.resolve(o.data[0]);break;case re.Stdout:await r.enqueue(o.data);break;case re.Stderr:await i.enqueue(o.data);break}}})).then(()=>{r.close(),i.close(),a.reject(new Error("Socket ended without exit message"))},o=>{r.error(o),i.error(o),a.reject(o)}),t&&t.addEventListener("abort",()=>{a.reject(t.reason),n(this,we).close()}),l(this,Ke,n(this,we).writable.getWriter()),l(this,Ge,new Ot({write:async o=>{await n(this,Ke).write(We.serialize({id:re.Stdin,data:o}))}}))}get stdin(){return n(this,Ge)}get stdout(){return n(this,He)}get stderr(){return n(this,Ye)}get exited(){return n(this,Ze)}kill(){return n(this,we).close()}}we=new WeakMap,Ke=new WeakMap,Ge=new WeakMap,He=new WeakMap,Ye=new WeakMap,Ze=new WeakMap;var Re,Le,Xe,Qe,fe,Je,or;class sn{constructor(e){c(this,Je);c(this,Re);c(this,Le);c(this,Xe);c(this,Qe);c(this,fe,new A);l(this,Re,e);let t;l(this,Qe,new Ut(r=>{t=r})),e.readable.pipeThrough(new $r(We)).pipeTo(new Ce({write:async r=>{switch(r.id){case re.Exit:n(this,fe).resolve(r.data[0]);break;case re.Stdout:await t.enqueue(r.data);break}}})).then(()=>{t.close(),n(this,fe).reject(new Error("Socket ended without exit message"))},r=>{t.error(r),n(this,fe).reject(r)}),l(this,Le,n(this,Re).writable.getWriter()),l(this,Xe,new Ot({write:r=>b(this,Je,or).call(this,r)}))}get input(){return n(this,Xe)}get output(){return n(this,Qe)}get exited(){return n(this,fe).promise}async resize(e,t){await n(this,Le).write(We.serialize({id:re.WindowSizeChange,data:se(`${e}x${t},0x0\0`)}))}sigint(){return b(this,Je,or).call(this,new Uint8Array([3]))}kill(){return n(this,Re).close()}}Re=new WeakMap,Le=new WeakMap,Xe=new WeakMap,Qe=new WeakMap,fe=new WeakMap,Je=new WeakSet,or=function(e){return n(this,Le).write(We.serialize({id:re.Stdin,data:e}))};var et;class nn{constructor(e){c(this,et);l(this,et,e)}spawn(e,t){return t==null||t.throwIfAborted(),typeof e=="string"&&(e=Yr(e)),n(this,et).call(this,e,t)}async spawnWait(e){const t=await this.spawn(e),[r,i,a]=await Promise.all([t.stdout.pipeThrough(new ir),t.stderr.pipeThrough(new ir),t.exited]);return{stdout:r,stderr:i,exitCode:a}}async spawnWaitText(e){const t=await this.spawn(e),[r,i,a]=await Promise.all([t.stdout.pipeThrough(new Vt).pipeThrough(new Wt),t.stderr.pipeThrough(new Vt).pipeThrough(new Wt),t.exited]);return{stdout:r,stderr:i,exitCode:a}}}et=new WeakMap;var X;class an extends nn{constructor(t){super(async(r,i)=>{const a=await n(this,X).createSocket(`shell,v2,raw:${r.join(" ")}`);if(i!=null&&i.aborted)throw await a.close(),i.reason;return new rn(a,i)});c(this,X);l(this,X,t)}get adb(){return n(this,X)}get isSupported(){return n(this,X).canUseFeature(y.ShellV2)}async pty(t){let r="shell,v2,pty";return t!=null&&t.terminalType&&(r+=",TERM="+t.terminalType),r+=":",t&&(typeof t.command=="string"?r+=t.command:Array.isArray(t.command)&&(r+=t.command.join(" "))),new sn(await n(this,X).createSocket(r))}}X=new WeakMap;var tt,rt,st;class on{constructor(e){c(this,tt);c(this,rt);c(this,st);l(this,tt,e),l(this,rt,new tn(e)),e.canUseFeature(y.ShellV2)&&l(this,st,new an(e))}get adb(){return n(this,tt)}get noneProtocol(){return n(this,rt)}get shellProtocol(){return n(this,st)}}tt=new WeakMap,rt=new WeakMap,st=new WeakMap;function cn(s){const e=new Uint8Array(s.length);for(let t=0;t<s.length;t+=1)e[t]=s.charCodeAt(t);return e}function p(s){const e=cn(s);return Qt(e,0)}const I={Entry:p("DENT"),Entry2:p("DNT2"),Lstat:p("STAT"),Stat:p("STA2"),Lstat2:p("LST2"),Done:p("DONE"),Data:p("DATA"),Ok:p("OKAY"),Fail:p("FAIL")};class ln extends Error{}const Zr=D({message:mr(d)},{littleEndian:!0,postDeserialize(s){throw new ln(s.message)}});async function $t(s,e,t){typeof e=="string"&&(e=p(e));const r=await s.readExactly(4);switch(Qt(r,0)){case I.Fail:throw await Zr.deserialize(s),new Error("Unreachable");case e:return await t.deserialize(s);default:throw new Error(`Expected '${e}', but got '${Nt(r)}'`)}}async function*Mt(s,e,t){for(typeof e=="string"&&(e=p(e));;){const r=await s.readExactly(4);switch(Qt(r,0)){case I.Fail:await Zr.deserialize(s),_s();case I.Done:await s.readExactly(t.size);return;case e:yield await t.deserialize(s);break;default:throw new Error(`Expected '${e}' or '${I.Done}', but got '${Nt(r)}'`)}}}const F={List:p("LIST"),ListV2:p("LIS2"),Send:p("SEND"),SendV2:p("SND2"),Lstat:p("STAT"),Stat:p("STA2"),LstatV2:p("LST2"),Data:p("DATA"),Done:p("DONE"),Receive:p("RECV")},Ir=D({id:d,arg:d},{littleEndian:!0});async function B(s,e,t){if(typeof e=="string"&&(e=p(e)),typeof t=="number"){await s.write(Ir.serialize({id:e,arg:t}));return}typeof t=="string"&&(t=se(t)),await s.write(Ir.serialize({id:e,arg:t.length})),await s.write(t)}const Xr={Directory:4,File:8,Link:10},Qr=D({mode:d,size:d,mtime:d},{littleEndian:!0,extra:{get type(){return this.mode>>12},get permission(){return this.mode&4095}},postDeserialize(s){if(s.mode===0&&s.size===0&&s.mtime===0)throw new Error("lstat error");return s}}),Jr={SUCCESS:0,EACCES:13,EEXIST:17,EFAULT:14,EFBIG:27,EINTR:4,EINVAL:22,EIO:5,EISDIR:21,ELOOP:40,EMFILE:24,ENAMETOOLONG:36,ENFILE:23,ENOENT:2,ENOMEM:12,ENOSPC:28,ENOTDIR:20,EOVERFLOW:75,EPERM:1,EROFS:30,ETXTBSY:26},hn=Object.fromEntries(Object.entries(Jr).map(([s,e])=>[e,s])),vr=D({error:d(),dev:Te,ino:Te,mode:d,nlink:d,uid:d,gid:d,size:Te,atime:Te,mtime:Te,ctime:Te},{littleEndian:!0,extra:{get type(){return this.mode>>12},get permission(){return this.mode&4095}},postDeserialize(s){if(s.error)throw new Error(hn[s.error]);return s}});async function dn(s,e,t){const r=await s.lock();try{if(t)return await B(r,F.LstatV2,e),await $t(r,I.Lstat2,vr);{await B(r,F.Lstat,e);const i=await $t(r,I.Lstat,Qr);return{mode:i.mode,size:BigInt(i.size),mtime:BigInt(i.mtime),get type(){return i.type},get permission(){return i.permission}}}}finally{r.release()}}async function un(s,e){const t=await s.lock();try{return await B(t,F.Stat,e),await $t(t,I.Stat,vr)}finally{t.release()}}const wn=Sr(Qr,{name:mr(d)}),fn=Sr(vr,{name:mr(d)});async function*yn(s,e){const t=await s.lock();try{await B(t,F.ListV2,e);for await(const r of Mt(t,I.Entry2,fn))r.error===Jr.SUCCESS&&(yield r)}finally{t.release()}}async function*bn(s,e){const t=await s.lock();try{await B(t,F.List,e);for await(const r of Mt(t,I.Entry,wn))yield r}finally{t.release()}}async function*pn(s,e,t){if(t)yield*yn(s,e);else for await(const r of bn(s,e))yield{mode:r.mode,size:BigInt(r.size),mtime:BigInt(r.mtime),get type(){return r.type},get permission(){return r.permission},name:r.name}}const Dr=D({data:Lt(d)},{littleEndian:!0});async function*gn(s,e){const t=await s.lock();let r=!1;try{await B(t,F.Receive,e);for await(const i of Mt(t,I.Data,Dr))yield i.data;r=!0}catch(i){throw r=!0,i}finally{if(!r)for await(const i of Mt(t,I.Data,Dr));t.release()}}function mn(s,e){return pr.from(gn(s,e))}const es=64*1024,Sn=D({unused:d},{littleEndian:!0});async function ts(s,e,t,r){const i=new Jt;e.pipeThrough(new Vs(t,!0)).pipeTo(new Ot({write(a){return B(s,F.Data,a)}}),{signal:i.signal}).then(async()=>{await B(s,F.Done,r),await s.flush()},Rs),await $t(s,I.Ok,Sn).catch(a=>{throw i.abort(),a})}async function vn({socket:s,filename:e,file:t,type:r=Xr.File,permission:i=438,mtime:a=Date.now()/1e3|0,packetSize:o=es}){const h=await s.lock();try{const u=r<<12|i,w=`${e},${u.toString()}`;await B(h,F.Send,w),await ts(h,t,o,a)}finally{h.release()}}const _r={None:0,Brotli:1,Lz4:2,Zstd:4,DryRun:2147483648},En=D({id:d,mode:d,flags:d()},{littleEndian:!0});async function An({socket:s,filename:e,file:t,type:r=Xr.File,permission:i=438,mtime:a=Date.now()/1e3|0,packetSize:o=es,dryRun:h=!1}){const u=await s.lock();try{await B(u,F.SendV2,e);const w=r<<12|i;let m=_r.None;h&&(m|=_r.DryRun),await u.write(En.serialize({id:F.SendV2,mode:w,flags:m})),await ts(u,t,o,a)}finally{u.release()}}function kn(s){if(s.v2)return An(s);if(s.dryRun)throw new Error("dryRun is not supported in v1");return vn(s)}var nt,ye,it,be,pe,at,cr;class xn{constructor(e,t,r,i){c(this,at);c(this,nt);c(this,ye);c(this,it);c(this,be,new Gr);c(this,pe);l(this,nt,e),l(this,ye,t),l(this,it,i),l(this,pe,new qr(r))}get position(){return n(this,ye).position}async flush(){try{await n(this,be).wait();const e=n(this,pe).flush();e&&await b(this,at,cr).call(this,e)}finally{n(this,be).notifyOne()}}async write(e){try{await n(this,be).wait();for(const t of n(this,pe).push(e))await b(this,at,cr).call(this,t)}finally{n(this,be).notifyOne()}}async readExactly(e){return await this.flush(),await n(this,ye).readExactly(e)}release(){n(this,pe).flush(),n(this,it).notifyOne()}async close(){await n(this,ye).cancel()}}nt=new WeakMap,ye=new WeakMap,it=new WeakMap,be=new WeakMap,pe=new WeakMap,at=new WeakSet,cr=function(e){return G.WritableStream.write(n(this,nt),e)};var ot,ct,Ne;class Cn{constructor(e,t){c(this,ot,new Gr);c(this,ct);c(this,Ne);l(this,ct,e),l(this,Ne,new xn(e.writable.getWriter(),new gr(e.readable),t,n(this,ot)))}async lock(){return await n(this,ot).wait(),n(this,Ne)}async close(){await n(this,Ne).close(),await n(this,ct).close()}}ot=new WeakMap,ct=new WeakMap,Ne=new WeakMap;function Tn(s){const e=s.lastIndexOf("/");if(e===-1)throw new Error("Invalid path");return e===0?"/":s.substring(0,e)}var ge,lt,ht,dt,ut;class Pn{constructor(e,t){f(this,"_adb");f(this,"_socket");c(this,ge);c(this,lt);c(this,ht);c(this,dt);c(this,ut);this._adb=e,this._socket=new Cn(t,e.maxPayloadSize),l(this,ge,e.canUseFeature(y.StatV2)),l(this,lt,e.canUseFeature(y.ListV2)),l(this,ht,e.canUseFeature(y.FixedPushMkdir)),l(this,dt,e.canUseFeature(y.SendReceiveV2)),l(this,ut,this._adb.canUseFeature(y.ShellV2)&&!this.fixedPushMkdir)}get supportsStat(){return n(this,ge)}get supportsListV2(){return n(this,lt)}get fixedPushMkdir(){return n(this,ht)}get supportsSendReceiveV2(){return n(this,dt)}get needPushMkdirWorkaround(){return n(this,ut)}async lstat(e){return await dn(this._socket,e,n(this,ge))}async stat(e){if(!n(this,ge))throw new Error("Not supported");return await un(this._socket,e)}async isDirectory(e){try{return await this.lstat(e+"/"),!0}catch{return!1}}opendir(e){return pn(this._socket,e,this.supportsListV2)}async readdir(e){const t=[];for await(const r of this.opendir(e))t.push(r);return t}read(e){return mn(this._socket,e)}async write(e){this.needPushMkdirWorkaround&&await this._adb.subprocess.noneProtocol.spawnWait(["mkdir","-p",ar(Tn(e.filename))]),await kn({v2:this.supportsSendReceiveV2,socket:this._socket,...e})}lockSocket(){return this._socket.lock()}dispose(){return this._socket.close()}}ge=new WeakMap,lt=new WeakMap,ht=new WeakMap,dt=new WeakMap,ut=new WeakMap;function Rr(s){if(!(!s||s==="0"))return Number.parseInt(s,10)}class In extends Mr{async getListenAddresses(){const e=await this.adb.getProp("service.adb.listen_addrs"),t=await this.adb.getProp("service.adb.tcp.port"),r=await this.adb.getProp("persist.adb.tcp.port");return{serviceListenAddresses:e!=""?e.split(","):[],servicePort:Rr(t),persistPort:Rr(r)}}async setPort(e){if(e<=0)throw new TypeError(`Invalid port ${e}`);const t=await this.adb.createSocketAndWait(`tcpip:${e}`);if(t!==`restarting in TCP mode port: ${e}
`)throw new Error(t);return t}async disable(){const e=await this.adb.createSocketAndWait("usb:");if(e!==`restarting in USB mode
`)throw new Error(e);return e}}var T;class Dn{constructor(e){c(this,T);f(this,"subprocess");f(this,"power");f(this,"reverse");f(this,"tcpip");l(this,T,e),this.subprocess=new on(this),this.power=new Ks(this),this.reverse=new Ls(this),this.tcpip=new In(this)}get transport(){return n(this,T)}get serial(){return n(this,T).serial}get maxPayloadSize(){return n(this,T).maxPayloadSize}get banner(){return n(this,T).banner}get disconnected(){return n(this,T).disconnected}get clientFeatures(){return n(this,T).clientFeatures}get deviceFeatures(){return this.banner.features}canUseFeature(e){return this.clientFeatures.includes(e)&&this.deviceFeatures.includes(e)}async createSocket(e){return n(this,T).connect(e)}async createSocketAndWait(e){return await(await this.createSocket(e)).readable.pipeThrough(new Vt).pipeThrough(new Wt)}getProp(e){return this.subprocess.noneProtocol.spawnWaitText(["getprop",e]).then(t=>t.trim())}rm(e,t){const r=["rm"];if(t!=null&&t.recursive&&r.push("-r"),t!=null&&t.force&&r.push("-f"),Array.isArray(e))for(const i of e)r.push(ar(i));else r.push(ar(e));return r.push("</dev/null"),this.subprocess.noneProtocol.spawnWaitText(r)}async sync(){const e=await this.createSocket("sync:");return new Pn(this,e)}async framebuffer(){return qs(this)}async close(){await n(this,T).close()}}T=new WeakMap;const Ft={Product:"ro.product.name",Model:"ro.product.model",Device:"ro.product.device",Features:"features"};var wt,ft,yt,bt;const Er=class Er{constructor(e,t,r,i){c(this,wt);c(this,ft);c(this,yt);c(this,bt,[]);l(this,wt,e),l(this,ft,t),l(this,yt,r),l(this,bt,i)}static parse(e){let t,r,i,a=[];const o=e.split("::");if(o.length>1){const h=o[1];for(const u of h.split(";")){if(!u)continue;const w=u.split("=");if(w.length!==2)continue;const[m,k]=w;switch(m){case Ft.Product:t=k;break;case Ft.Model:r=k;break;case Ft.Device:i=k;break;case Ft.Features:a=k.split(",");break}}}return new Er(t,r,i,a)}get product(){return n(this,wt)}get model(){return n(this,ft)}get device(){return n(this,yt)}get features(){return n(this,bt)}};wt=new WeakMap,ft=new WeakMap,yt=new WeakMap,bt=new WeakMap;let jt=Er;function lr(s,e,t){let r=0n;for(let i=e;i<e+t;i+=8){r<<=64n;const a=ks(s,i);r|=a}return r}function hr(s,e,t,r,i){if(i)for(;r>0n;)zs(s,e,r),e+=8,r>>=64n;else{let a=e+t-8;for(;r>0n;)Us(s,a,r),a-=8,r>>=64n}}const _n=38,Rn=2048/8,Ln=303,Nn=2048/8;function rs(s){const e=lr(s,_n,Rn),t=lr(s,Ln,Nn);return[e,t]}function Lr(s,e){const t=s%e;return t>0?t:t+(e>0?e:-e)}function On(s,e){if(s=Lr(s,e),!s||e<2)return NaN;const t=[];let r=e;for(;r;)[s,r]=[r,s%r],t.push({a:s,b:r});if(s!==1)return NaN;let i=1,a=0;for(let o=t.length-2;o>=0;o-=1)[i,a]=[a,i-a*Math.floor(t[o].a/t[o].b)];return Lr(a,e)}const oe=2048/8,Fn=oe/4;function ss(){return 8+oe+oe+4}function zn(s,e){let t;const r=ss();if(!e)e=new Uint8Array(r),t="Uint8Array";else{if(e.length<r)throw new TypeError("output buffer is too small");t="number"}const i=new DataView(e.buffer,e.byteOffset,e.length);let a=0;i.setUint32(a,Fn,!0),a+=4;const[o]=rs(s),h=-On(Number(o%2n**32n),2**32);i.setInt32(a,h,!0),a+=4,hr(e,a,oe,o,!0),a+=oe;const u=2n**4096n%o;return hr(e,a,oe,u,!0),a+=oe,i.setUint32(a,65537,!0),a+=4,t==="Uint8Array"?e:r}function Un(s,e,t){if(t===1n)return 0n;let r=1n;for(s=s%t;e>0n;)BigInt.asUintN(1,e)===1n&&(r=r*s%t),s=s*s%t,e>>=1n;return r}const Nr=20,Or=48,Vn=4,Bn=5,Wn=6,sr=new Uint8Array([Or,13+Nr,Or,9,Wn,5,43,14,3,2,26,Bn,0,Vn,Nr]);function $n(s,e){const[t,r]=rs(s),i=new Uint8Array(256);let a=0;i[a]=0,a+=1,i[a]=1,a+=1;const o=i.length-sr.length-e.length-1;for(;a<o;)i[a]=255,a+=1;i[a]=0,a+=1,i.set(sr,a),a+=sr.length,i.set(e,a);const h=Un(lr(i,0,i.length),r,t);return hr(i,0,i.length,h,!1),i}const v={Auth:1213486401,Close:1163086915,Connect:1314410051,Okay:1497451343,Open:1313165391,Write:1163154007},dr=D({command:d,arg0:d,arg1:d,payloadLength:d,checksum:d,magic:xs},{littleEndian:!0}),di=Sr(dr,{payload:Lt("payloadLength")});function ns(s){return s.reduce((e,t)=>e+t,0)}class ui extends Wr{constructor(){const e=new Uint8Array(dr.size);super({transform:async(t,r)=>{await t.tryConsume(async i=>{const a=i;a.payloadLength=a.payload.length,dr.serialize(a,e),await G.ReadableStream.enqueue(r,e),a.payloadLength&&await G.ReadableStream.enqueue(r,a.payload)})}})}}const qt={Token:1,Signature:2,PublicKey:3},Mn=async function*(s,e){for await(const t of s.iterateKeys()){const r=await e();if(r.arg0!==qt.Token)return;const i=$n(t.buffer,r.payload);yield{command:v.Auth,arg0:qt.Signature,arg1:0,payload:i}}},jn=async function*(s,e){var u;if((await e()).arg0!==qt.Token)return;let r;for await(const w of s.iterateKeys()){r=w;break}r||(r=await s.generateKey());const i=ss(),[a]=Hr(i),o=(u=r.name)!=null&&u.length?se(r.name):ae,h=new Uint8Array(a+(o.length?o.length+1:0)+1);zn(r.buffer,h),Gs(h.subarray(0,i),h),o.length&&(h[a]=32,h.set(o,a+1)),yield{command:v.Auth,arg0:qt.PublicKey,arg1:0,payload:h}},qn=[Mn,jn];var pt,Oe,me,Ht,Yt,is;class Kn{constructor(e,t){c(this,Yt);f(this,"authenticators");c(this,pt);c(this,Oe,new A);c(this,me);c(this,Ht,()=>n(this,Oe).promise);this.authenticators=e,l(this,pt,t)}async process(e){n(this,me)||l(this,me,b(this,Yt,is).call(this)),n(this,Oe).resolve(e);const t=await n(this,me).next();if(t.done)throw new Error("No authenticator can handle the request");return t.value}dispose(){var e,t;(t=(e=n(this,me))==null?void 0:e.return)==null||t.call(e)}}pt=new WeakMap,Oe=new WeakMap,me=new WeakMap,Ht=new WeakMap,Yt=new WeakSet,is=async function*(){for(const e of this.authenticators)for await(const t of e(n(this,pt),n(this,Ht)))l(this,Oe,new A),yield t};var Se,gt,Fe,mt,St,vt,Et,ve,K,Zt,as;class Fr{constructor(e){c(this,Zt);c(this,Se);f(this,"localId");f(this,"remoteId");f(this,"localCreated");f(this,"service");c(this,gt);c(this,Fe);c(this,mt);f(this,"writable");c(this,St,!1);c(this,vt,new A);c(this,Et);c(this,ve);c(this,K,0);l(this,Se,e.dispatcher),this.localId=e.localId,this.remoteId=e.remoteId,this.localCreated=e.localCreated,this.service=e.service,l(this,gt,new Ut(t=>{l(this,Fe,t)})),this.writable=new Ot({start:t=>{l(this,mt,t),t.signal.addEventListener("abort",()=>{var r;(r=n(this,ve))==null||r.reject(t.signal.reason)})},write:async t=>{const r=t.length,i=n(this,Se).options.maxPayloadSize;for(let a=0,o=i;a<r;a=o,o+=i){const h=t.subarray(a,o);await b(this,Zt,as).call(this,h)}}}),l(this,Et,new Gn(this)),l(this,K,e.availableWriteBytes)}get readable(){return n(this,gt)}get closed(){return n(this,vt).promise}get socket(){return n(this,Et)}async enqueue(e){await n(this,Fe).enqueue(e)}ack(e){var t;l(this,K,n(this,K)+e),(t=n(this,ve))==null||t.resolve()}async close(){var e;if(!n(this,St)){l(this,St,!0),(e=n(this,ve))==null||e.reject(new Error("Socket closed"));try{n(this,mt).error(new Error("Socket closed"))}catch{}await n(this,Se).sendPacket(v.Close,this.localId,this.remoteId,ae)}}dispose(){n(this,Fe).close(),n(this,vt).resolve(void 0)}}Se=new WeakMap,gt=new WeakMap,Fe=new WeakMap,mt=new WeakMap,St=new WeakMap,vt=new WeakMap,Et=new WeakMap,ve=new WeakMap,K=new WeakMap,Zt=new WeakSet,as=async function(e){const t=e.length;for(;n(this,K)<t;){const r=new A;l(this,ve,r),await r.promise}n(this,K)===1/0?l(this,K,-1):l(this,K,n(this,K)-t),await n(this,Se).sendPacket(v.Write,this.localId,this.remoteId,e)};var P;class Gn{constructor(e){c(this,P);l(this,P,e)}get localId(){return n(this,P).localId}get remoteId(){return n(this,P).remoteId}get localCreated(){return n(this,P).localCreated}get service(){return n(this,P).service}get readable(){return n(this,P).readable}get writable(){return n(this,P).writable}get closed(){return n(this,P).closed}close(){return n(this,P).close()}}P=new WeakMap;var Q,L,Ee,At,ze,Ae,kt,E,os,cs,ur,ls,hs,wr;class Hn{constructor(e,t){c(this,E);c(this,Q,new Fs(1));c(this,L,new Map);c(this,Ee);f(this,"options");c(this,At,!1);c(this,ze,new A);c(this,Ae,new Map);c(this,kt,new Jt);this.options=t,this.options.initialDelayedAckBytes<0&&(this.options.initialDelayedAckBytes=0),e.readable.pipeTo(new Ce({write:async r=>{switch(r.command){case v.Close:await b(this,E,os).call(this,r);break;case v.Okay:b(this,E,cs).call(this,r);break;case v.Open:await b(this,E,ls).call(this,r);break;case v.Write:await b(this,E,hs).call(this,r);break;default:throw new Error(`Unknown command: ${r.command.toString(16)}`)}}}),{preventCancel:t.preserveConnection??!1,signal:n(this,kt).signal}).then(()=>{b(this,E,wr).call(this)},r=>{n(this,At)||n(this,ze).reject(r),b(this,E,wr).call(this)}),l(this,Ee,e.writable.getWriter())}get disconnected(){return n(this,ze).promise}async createSocket(e){this.options.appendNullToServiceString&&(e+="\0");const[t,r]=n(this,Q).add();await this.sendPacket(v.Open,t,this.options.initialDelayedAckBytes,e);const{remoteId:i,availableWriteBytes:a}=await r,o=new Fr({dispatcher:this,localId:t,remoteId:i,localCreated:!0,service:e,availableWriteBytes:a});return n(this,L).set(t,o),o.socket}addReverseTunnel(e,t){n(this,Ae).set(e,t)}removeReverseTunnel(e){n(this,Ae).delete(e)}clearReverseTunnels(){n(this,Ae).clear()}async sendPacket(e,t,r,i){if(typeof i=="string"&&(i=se(i)),i.length>this.options.maxPayloadSize)throw new TypeError("payload too large");await G.WritableStream.write(n(this,Ee),{command:e,arg0:t,arg1:r,payload:i,checksum:this.options.calculateChecksum?ns(i):0,magic:e^4294967295})}async close(){await Promise.all(Array.from(n(this,L).values(),e=>e.close())),l(this,At,!0),n(this,kt).abort(),this.options.preserveConnection?n(this,Ee).releaseLock():await n(this,Ee).close()}}Q=new WeakMap,L=new WeakMap,Ee=new WeakMap,At=new WeakMap,ze=new WeakMap,Ae=new WeakMap,kt=new WeakMap,E=new WeakSet,os=async function(e){if(e.arg0===0&&n(this,Q).reject(e.arg1,new Error("Socket open failed")))return;const t=n(this,L).get(e.arg1);if(t){await t.close(),t.dispose(),n(this,L).delete(e.arg1);return}},cs=function(e){let t;if(this.options.initialDelayedAckBytes!==0){if(e.payload.length!==4)throw new Error("Invalid OKAY packet. Payload size should be 4");t=Qt(e.payload,0)}else{if(e.payload.length!==0)throw new Error("Invalid OKAY packet. Payload size should be 0");t=1/0}if(n(this,Q).resolve(e.arg1,{remoteId:e.arg0,availableWriteBytes:t}))return;const r=n(this,L).get(e.arg1);if(r){r.ack(t);return}this.sendPacket(v.Close,e.arg1,e.arg0,ae)},ur=function(e,t,r){let i;return this.options.initialDelayedAckBytes!==0?(i=new Uint8Array(4),vs(i,0,r)):i=ae,this.sendPacket(v.Okay,e,t,i)},ls=async function(e){const[t]=n(this,Q).add();n(this,Q).resolve(t,void 0);const r=e.arg0;let i=e.arg1,a=Nt(e.payload);if(a.endsWith("\0")&&(a=a.substring(0,a.length-1)),this.options.initialDelayedAckBytes===0){if(i!==0)throw new Error("Invalid OPEN packet. arg1 should be 0");i=1/0}else if(i===0)throw new Error("Invalid OPEN packet. arg1 should be greater than 0");const o=n(this,Ae).get(a);if(!o){await this.sendPacket(v.Close,0,r,ae);return}const h=new Fr({dispatcher:this,localId:t,remoteId:r,localCreated:!1,service:a,availableWriteBytes:i});try{await o(h.socket),n(this,L).set(t,h),await b(this,E,ur).call(this,t,r,this.options.initialDelayedAckBytes)}catch{await this.sendPacket(v.Close,0,r,ae)}},hs=async function(e){const t=n(this,L).get(e.arg1);if(!t)throw new Error(`Unknown local socket id: ${e.arg1}`);let r=!1;const i=[(async()=>{await t.enqueue(e.payload),await b(this,E,ur).call(this,e.arg1,e.arg0,e.payload.length),r=!0})()];this.options.readTimeLimit&&i.push((async()=>{if(await Ns(this.options.readTimeLimit),!r)throw new Error(`readable of \`${t.service}\` has stalled for ${this.options.readTimeLimit} milliseconds`)})()),await Promise.race(i)},wr=function(){for(const e of n(this,L).values())e.dispose();n(this,ze).resolve()};const Yn=16777217,zr=[y.ShellV2,y.Cmd,y.StatV2,y.ListV2,y.FixedPushMkdir,"apex",y.Abb,"fixed_push_symlink_timestamp",y.AbbExec,"remount_shell","track_app",y.SendReceiveV2,"sendrecv_v2_brotli","sendrecv_v2_lz4","sendrecv_v2_zstd","sendrecv_v2_dry_run_send",y.DelayedAck],Zn=32*1024*1024;var xt,N,Ct,Tt,Ue,Pt;const Ar=class Ar{constructor({serial:e,connection:t,version:r,banner:i,features:a=zr,initialDelayedAckBytes:o,...h}){c(this,xt);c(this,N);c(this,Ct);c(this,Tt);c(this,Ue);c(this,Pt);if(l(this,Ct,e),l(this,xt,t),l(this,Ue,jt.parse(i)),l(this,Pt,a),a.includes(y.DelayedAck)){if(o<=0)throw new TypeError("`initialDelayedAckBytes` must be greater than 0 when DelayedAck feature is enabled.");n(this,Ue).features.includes(y.DelayedAck)||(o=0)}else o=0;let u,w;r>=Yn?(u=!1,w=!1):(u=!0,w=!0),l(this,N,new Hn(t,{calculateChecksum:u,appendNullToServiceString:w,initialDelayedAckBytes:o,...h})),l(this,Tt,r)}static async authenticate({serial:e,connection:t,credentialStore:r,authenticators:i=qn,features:a=zr,initialDelayedAckBytes:o=Zn,...h}){let u=16777217,w=1024*1024;const m=new A,k=new Kn(i,r),W=new Jt,ne=t.readable.pipeTo(new Ce({async write(S){switch(S.command){case v.Connect:u=Math.min(u,S.arg0),w=Math.min(w,S.arg1),m.resolve(Nt(S.payload));break;case v.Auth:{const gs=await k.process(S);await kr(gs);break}}}}),{preventCancel:!0,signal:W.signal}).then(()=>{m.reject(new Error("Connection closed unexpectedly"))},S=>{m.reject(S)}),ie=t.writable.getWriter();async function kr(S){S.checksum=ns(S.payload),S.magic=S.command^4294967295,await G.WritableStream.write(ie,S)}const er=a.slice();if(o<=0){const S=a.indexOf(y.DelayedAck);S!==-1&&er.splice(S,1)}let xr;try{await kr({command:v.Connect,arg0:u,arg1:w,payload:se(`host::features=${er.join(",")}`)}),xr=await m.promise}finally{W.abort(),ie.releaseLock(),await ne}return new Ar({serial:e,connection:t,version:u,maxPayloadSize:w,banner:xr,features:er,initialDelayedAckBytes:o,...h})}get connection(){return n(this,xt)}get serial(){return n(this,Ct)}get protocolVersion(){return n(this,Tt)}get maxPayloadSize(){return n(this,N).options.maxPayloadSize}get banner(){return n(this,Ue)}get disconnected(){return n(this,N).disconnected}get clientFeatures(){return n(this,Pt)}connect(e){return n(this,N).createSocket(e)}addReverseTunnel(e,t){return t||(t=`localabstract:reverse_${Math.random().toString().substring(2)}`),n(this,N).addReverseTunnel(t,e),t}removeReverseTunnel(e){n(this,N).removeReverseTunnel(e)}clearReverseTunnels(){n(this,N).clearReverseTunnels()}close(){return n(this,N).close()}};xt=new WeakMap,N=new WeakMap,Ct=new WeakMap,Tt=new WeakMap,Ue=new WeakMap,Pt=new WeakMap;let Ur=Ar;var Ve;class Xn{constructor(e){c(this,Ve);l(this,Ve,e)}async check(){const e=await n(this,Ve).createConnection("host:mdns:check");try{return!(await e.readString()).startsWith("ERROR:")}finally{await e.dispose()}}async getServices(){const e=await n(this,Ve).createConnection("host:mdns:services");try{return(await e.readString()).split(`
`).filter(Boolean).map(r=>{const i=r.split("	");return{name:i[0],service:i[1],address:i[2]}})}finally{await e.dispose()}}}Ve=new WeakMap;const Qn=se("OKAY"),ds=se("FAIL");var J,ee,ke;class Vr{constructor(e){c(this,J);c(this,ee);c(this,ke);f(this,"readString",Cs(function*(e){const t=yield*e(this.readExactly(4)),r=Bt(t);if(r===0)return"";{const i=new Is;let a="";const o=n(this,ee).iterateExactly(r);for(;;){const{done:h,value:u}=o.next();if(h)break;a+=i.decode(yield*e(u),{stream:!0})}return a+=i.decode(),a}}));l(this,J,e),l(this,ee,new gr(e.readable)),l(this,ke,e.writable.getWriter())}readExactly(e){return n(this,ee).readExactly(e)}async readOkay(){const e=await this.readExactly(4);if(!nr(e,Qn)){if(nr(e,ds)){const t=await this.readString();throw new Error(t)}throw new Error(`Unexpected response: ${Nt(e)}`)}}async writeString(e){const t=se(e),r=new Uint8Array(4+t.length);Os(r,0,t.length),r.set(t,4),await n(this,ke).write(r)}release(){return n(this,ke).releaseLock(),{readable:n(this,ee).release(),writable:n(this,J).writable,closed:n(this,J).closed,close:()=>n(this,J).close()}}async dispose(){Ts(n(this,ee)),Ps(n(this,ke)),await n(this,J).close()}}J=new WeakMap,ee=new WeakMap,ke=new WeakMap;class us extends Error{constructor(e){super(e),this.name="NetworkError"}}class ws extends Error{constructor(e){super(e),this.name="UnauthorizedError"}}class fs extends Error{constructor(e){super(e),this.name="AlreadyConnectedError"}}var xe;class Jn{constructor(e){c(this,xe);l(this,xe,e)}async pair(e,t){const r=await n(this,xe).createConnection(`host:pair:${t}:${e}`);try{const i=await r.readExactly(4);if(nr(i,ds))throw new Error(await r.readString());const a=Bt(i);await r.readExactly(a)}finally{await r.dispose()}}async connect(e){const t=await n(this,xe).createConnection(`host:connect:${e}`);try{const r=await t.readString();switch(r){case`already connected to ${e}`:throw new fs(r);case`failed to connect to ${e}`:case`failed to authenticate to ${e}`:throw new ws(r);case`connected to ${e}`:return;default:throw new us(r)}}finally{await t.dispose()}}async disconnect(e){const t=await n(this,xe).createConnection(`host:disconnect:${e}`);try{await t.readString()}finally{await t.dispose()}}}xe=new WeakMap;function Br(s,e){e<0||e>=s.length||(s[e]=s[s.length-1],s.length-=1)}function zt(s,e){return s.filter(t=>e.includes(t.state))}var It,V,O,z,fr,ys,bs,ps;class ei{constructor(e){c(this,z);f(this,"current",[]);c(this,It);c(this,V);c(this,O,[]);l(this,It,e)}async createObserver(e){var W;(W=e==null?void 0:e.signal)==null||W.throwIfAborted();let t=[];const r=new Tr,i=new Tr,a=new Pr,o=new Pr,h=(e==null?void 0:e.includeStates)??["device","unauthorized"],u={includeStates:h,onDeviceAdd:r,onDeviceRemove:i,onListChange:a,onError:o};n(this,O).push(u),a.event(ne=>t=ne);let w;if(n(this,V))w=await n(this,V),a.fire(zt(this.current,h));else{l(this,V,b(this,z,bs).call(this));try{w=await n(this,V)}catch(ne){throw l(this,V,void 0),ne}}const m=new Xs(e),k=async()=>{Br(n(this,O),n(this,O).indexOf(u)),await b(this,z,ps).call(this,w),m.unref()};if(e!=null&&e.signal){if(e.signal.aborted)throw await k(),e.signal.reason;e.signal.addEventListener("abort",()=>void k())}return{onDeviceAdd:r.event,onDeviceRemove:i.event,onListChange:a.event,onError:o.event,get current(){return t},stop:k}}}It=new WeakMap,V=new WeakMap,O=new WeakMap,z=new WeakSet,fr=async function(e){const t=await e.readString(),r=yr.parseDeviceList(t),i=this.current.slice(),a=[];for(const o of r){const h=i.findIndex(u=>u.transportId===o.transportId);if(h===-1){a.push(o);continue}Br(i,h)}if(this.current=r,a.length)for(const o of n(this,O)){const h=zt(a,o.includeStates);h.length&&o.onDeviceAdd.fire(h)}if(i.length)for(const o of n(this,O))zt(i,o.includeStates).length&&o.onDeviceRemove.fire(i);for(const o of n(this,O)){const h=zt(this.current,o.includeStates);o.onListChange.fire(h)}},ys=async function(e){try{for(;;)await b(this,z,fr).call(this,e)}catch(t){l(this,V,void 0);for(const r of n(this,O))r.onError.fire(t)}},bs=async function(){const e=await n(this,It).createConnection("host:track-devices-l",{unref:!0});return await b(this,z,fr).call(this,e),b(this,z,ys).call(this,e),e},ps=async function(e){n(this,O).length===0&&(l(this,V,void 0),await e.dispose())};const ti=[y.ShellV2,y.Cmd,y.StatV2,y.ListV2,y.FixedPushMkdir,"apex",y.Abb,"fixed_push_symlink_timestamp",y.AbbExec,"remount_shell","track_app",y.SendReceiveV2,"sendrecv_v2_brotli","sendrecv_v2_lz4","sendrecv_v2_zstd","sendrecv_v2_dry_run_send"];var te,Be,Dt,_t;class ri{constructor(e,t,r,i,a){c(this,te);f(this,"serial");f(this,"transportId");f(this,"maxPayloadSize",1*1024*1024);f(this,"banner");c(this,Be,[]);c(this,Dt,new A);c(this,_t);l(this,te,e),this.serial=t,this.banner=r,this.transportId=i,l(this,_t,Promise.race([n(this,Dt).promise,a]))}get disconnected(){return n(this,_t)}get clientFeatures(){return ti}async connect(e){const t=await n(this,te).createDeviceConnection({transportId:this.transportId},e);return n(this,Be).push(t),t}async addReverseTunnel(e,t){return await n(this,te).connector.addReverseTunnel(e,t)}async removeReverseTunnel(e){await n(this,te).connector.removeReverseTunnel(e)}async clearReverseTunnels(){await n(this,te).connector.clearReverseTunnels()}async close(){for(const e of n(this,Be))await e.close();n(this,Be).length=0,n(this,Dt).resolve()}}te=new WeakMap,Be=new WeakMap,Dt=new WeakMap,_t=new WeakMap;var Xt,Rt,br;const H=class H{constructor(e){c(this,Rt);f(this,"connector");f(this,"wireless",new Jn(this));f(this,"mDns",new Xn(this));c(this,Xt,new ei(this));this.connector=e}static parseDeviceList(e,t=["device","unauthorized"]){const r=[];for(const i of e.split(`
`)){if(!i)continue;const a=i.split(" ").filter(Boolean),o=a[0],h=a[1];if(!t.includes(h))continue;let u,w,m,k;for(let W=2;W<a.length;W+=1){const[ne,ie]=a[W].split(":");switch(ne){case"product":u=ie;break;case"model":w=ie;break;case"device":m=ie;break;case"transport_id":k=BigInt(ie);break}}if(!k)throw new Error(`No transport id for device ${o}`);r.push({serial:o,state:h,authenticating:h==="unauthorized",product:u,model:w,device:m,transportId:k})}return r}static formatDeviceService(e,t){if(!e)return`host:${t}`;if("transportId"in e)return`host-transport-id:${e.transportId}:${t}`;if("serial"in e)return`host-serial:${e.serial}:${t}`;if("usb"in e)return`host-usb:${t}`;if("tcp"in e)return`host-local:${t}`;throw new TypeError("Invalid device selector")}async createConnection(e,t){const r=await this.connector.connect(t),i=new Vr(r);try{await i.writeString(e)}catch(a){throw await i.dispose(),a}try{return await si(()=>i.readOkay(),t==null?void 0:t.signal),i}catch(a){throw await i.dispose(),a}}async getVersion(){const e=await this.createConnection("host:version");try{const t=Bt(await e.readExactly(4));return Bt(await e.readExactly(t))}finally{await e.dispose()}}async validateVersion(e){const t=await this.getVersion();if(t<e)throw new Error(`adb server version (${t}) doesn't match this client (${e})`)}async killServer(){await(await this.createConnection("host:kill")).dispose()}async getServerFeatures(){const e=await this.createConnection("host:host-features");try{return(await e.readString()).split(",")}finally{await e.dispose()}}async getDevices(e=["device","unauthorized"]){const t=await this.createConnection("host:devices-l");try{const r=await t.readString();return H.parseDeviceList(r,e)}finally{await t.dispose()}}async trackDevices(e){return n(this,Xt).createObserver(e)}async reconnectDevice(e){const t=await this.createConnection(e==="offline"?"host:reconnect-offline":H.formatDeviceService(e,"reconnect"));try{await t.readString()}finally{await t.dispose()}}async getDeviceFeatures(e){const t=await this.createDeviceConnection(e,"host:features"),r=new Vr(t);try{const a=(await r.readString()).split(",");return{transportId:t.transportId,features:a}}finally{await r.dispose()}}async createDeviceConnection(e,t){let r,i;if(!e)await this.validateVersion(41),r="host:tport:any";else if("transportId"in e)r=`host:transport-id:${e.transportId}`,i=e.transportId;else if("serial"in e)await this.validateVersion(41),r=`host:tport:serial:${e.serial}`;else if("usb"in e)await this.validateVersion(41),r="host:tport:usb";else if("tcp"in e)await this.validateVersion(41),r="host:tport:local";else throw new TypeError("Invalid device selector");const a=await this.createConnection(r);try{await a.writeString(t)}catch(o){throw await a.dispose(),o}try{if(i===void 0){const h=await a.readExactly(8);i=Ds(h,0)}await a.readOkay();const o=a.release();return{transportId:i,service:t,readable:o.readable,writable:o.writable,get closed(){return o.closed},async close(){await o.close()}}}catch(o){throw await a.dispose(),o}}async waitFor(e,t,r){return t==="disconnect"&&await this.validateVersion(41),b(this,Rt,br).call(this,e,t,r)}async waitForDisconnect(e,t){if(await this.getVersion()>=41)return b(this,Rt,br).call(this,{transportId:e},"disconnect",t);{const i=await this.trackDevices(t);return new Promise((a,o)=>{i.onDeviceRemove(h=>{h.some(u=>u.transportId===e)&&(i.stop(),a())}),i.onError(h=>{i.stop(),o(h)})})}}async createTransport(e){const{transportId:t,features:r}=await this.getDeviceFeatures(e),a=(await this.getDevices()).find(m=>m.transportId===t),o=new jt(a==null?void 0:a.product,a==null?void 0:a.model,a==null?void 0:a.device,r),h=new Jt,u=this.waitForDisconnect(t,{unref:!0,signal:h.signal}),w=new ri(this,(a==null?void 0:a.serial)??"",o,t,u);return w.disconnected.finally(()=>h.abort()),w}async createAdb(e){const t=await this.createTransport(e);return new Dn(t)}};Xt=new WeakMap,Rt=new WeakSet,br=async function(e,t,r){let i;if(!e)i="any";else if("transportId"in e)i="any";else if("serial"in e)i="any";else if("usb"in e)i="usb";else if("tcp"in e)i="local";else throw new TypeError("Invalid device selector");const a=H.formatDeviceService(e,`wait-for-${i}-${t}`),o=await this.createConnection(a,r);try{await o.readOkay()}finally{await o.dispose()}},f(H,"NetworkError",us),f(H,"UnauthorizedError",ws),f(H,"AlreadyConnectedError",fs);let yr=H;async function si(s,...e){const t=new A;function r(){t.reject(this.reason)}try{for(const i of e)if(i){if(i.aborted)throw i.reason;i.addEventListener("abort",r)}return await Promise.race([s(),t.promise])}finally{for(const i of e)i&&i.removeEventListener("abort",r)}}export{zr as ADB_DAEMON_DEFAULT_FEATURES,Zn as ADB_DAEMON_DEFAULT_INITIAL_PAYLOAD_SIZE,Yn as ADB_DAEMON_VERSION_OMIT_CHECKSUM,qn as ADB_DEFAULT_AUTHENTICATORS,ti as ADB_SERVER_DEFAULT_FEATURES,es as ADB_SYNC_MAX_PACKET_SIZE,Bn as ASN1_NULL,Vn as ASN1_OCTET_STRING,Wn as ASN1_OID,Or as ASN1_SEQUENCE,Dn as Adb,qt as AdbAuthType,Kn as AdbAuthenticationProcessor,jt as AdbBanner,Ft as AdbBannerKey,v as AdbCommand,Gn as AdbDaemonSocket,Fr as AdbDaemonSocketController,Ur as AdbDaemonTransport,y as AdbFeature,Kr as AdbFrameBufferError,js as AdbFrameBufferForbiddenError,Ms as AdbFrameBufferUnsupportedVersionError,Ws as AdbFrameBufferV1,$s as AdbFrameBufferV2,Qs as AdbNoneProtocolProcessImpl,Js as AdbNoneProtocolPtyProcess,en as AdbNoneProtocolSpawner,tn as AdbNoneProtocolSubprocessService,di as AdbPacket,Hn as AdbPacketDispatcher,dr as AdbPacketHeader,ui as AdbPacketSerializeStream,Ks as AdbPower,jn as AdbPublicKeyAuthenticator,yi as AdbReverseError,bi as AdbReverseNotSupportedError,Ls as AdbReverseService,yr as AdbServerClient,ei as AdbServerDeviceObserverOwner,Vr as AdbServerStream,ri as AdbServerTransport,Mr as AdbServiceBase,re as AdbShellProtocolId,We as AdbShellProtocolPacket,rn as AdbShellProtocolProcessImpl,sn as AdbShellProtocolPtyProcess,nn as AdbShellProtocolSpawner,an as AdbShellProtocolSubprocessService,Mn as AdbSignatureAuthenticator,on as AdbSubprocessService,Pn as AdbSync,Dr as AdbSyncDataResponse,fn as AdbSyncEntry2Response,wn as AdbSyncEntryResponse,ln as AdbSyncError,Zr as AdbSyncFailResponse,Qr as AdbSyncLstatResponse,Ir as AdbSyncNumberRequest,Sn as AdbSyncOkResponse,F as AdbSyncRequestId,I as AdbSyncResponseId,_r as AdbSyncSendV2Flags,En as AdbSyncSendV2Request,Cn as AdbSyncSocket,xn as AdbSyncSocketLocked,Jr as AdbSyncStatErrorCode,vr as AdbSyncStatResponse,In as AdbTcpIpService,Gr as AutoResetEvent,ds as FAIL,Xr as LinuxFileType,Rs as NOOP,Xs as Ref,sr as SHA1_DIGEST_INFO,Nr as SHA1_DIGEST_LENGTH,zn as adbGeneratePublicKey,ss as adbGetPublicKeySize,p as adbSyncEncodeId,dn as adbSyncLstat,pn as adbSyncOpenDir,bn as adbSyncOpenDirV1,yn as adbSyncOpenDirV2,mn as adbSyncPull,gn as adbSyncPullGenerator,kn as adbSyncPush,vn as adbSyncPushV1,An as adbSyncPushV2,$t as adbSyncReadResponse,Mt as adbSyncReadResponses,un as adbSyncStat,B as adbSyncWriteRequest,Hr as calculateBase64EncodedLength,ns as calculateChecksum,hi as decodeBase64,Nt as decodeUtf8,Tn as dirname,Gs as encodeBase64,se as encodeUtf8,ar as escapeArg,qs as framebuffer,lr as getBigUint,Bt as hexToNumber,On as modInverse,Un as powMod,si as raceSignal,rs as rsaParsePrivateKey,$n as rsaSign,nr as sequenceEqual,hr as setBigUint,Yr as splitCommand,li as toLocalUint8Array,Br as unorderedRemove,_s as unreachable,Os as write4HexDigits};
